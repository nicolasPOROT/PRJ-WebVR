<!DOCTYPE html>
<html>
    <head>
      <meta charset="utf-8" />
      <title>Projet WebVR</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />

      <!-- A-Frame 1.7.0 -->
      <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

      <!-- A-Frame 1.5+ : √©viter le conflit de nom "grabbable" -->
      <script> delete AFRAME.components["grabbable"]; </script> <!-- cf. super-hands -->

      <!-- aframe-extras (sphere-collider) -->
      <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

      <!-- Physics system (CANNON/Ammo support) -->
      <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

      <!-- super-hands 3.x -->
      <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

      <!-- Tes composants de d√©placement -->
      <script>
        // D√©placement joystick gauche
        AFRAME.registerComponent('joystick-movement', {
          schema: { speed: { type: 'number', default: 2 } },
          init: function () {
            const rig = document.querySelector('#rig');
            const head = document.querySelector('#head');
            const leftHand = document.querySelector('#leftHand');
            const speed = this.data.speed;
            const DEADZONE = 0.1;

            leftHand.addEventListener('thumbstickmoved', function (evt) {
              const dx = evt.detail.x, dy = evt.detail.y;
              if (Math.abs(dx) < DEADZONE && Math.abs(dy) < DEADZONE) return;

              const forward = new THREE.Vector3();
              head.object3D.getWorldDirection(forward);
              forward.y = 0; forward.normalize();

              const right = new THREE.Vector3();
              right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

              const step = 0.05 * speed;
              const rigPos = rig.object3D.position;
              rigPos.addScaledVector(forward, dy * step);
              rigPos.addScaledVector(right,  dx * step);
            });
          }
        });

        // Rotation par crans (joystick droit)
        AFRAME.registerComponent('snap-turn', {
          schema: { angle: { type: 'number', default: 30 }, cooldown: { type: 'number', default: 300 } },
          init: function () {
            const rig = document.querySelector('#rig');
            const rightHand = document.querySelector('#rightHand');
            const angle = this.data.angle, cooldown = this.data.cooldown;
            let lastTurn = 0;
            rightHand.addEventListener('thumbstickmoved', function (evt) {
              const now = Date.now(), x = evt.detail.x;
              if (Math.abs(x) < 0.8 || now - lastTurn < cooldown) return;
              const rad = THREE.MathUtils.degToRad(angle);
              if (x > 0.8)  rig.object3D.rotation.y -= rad;
              else          rig.object3D.rotation.y += rad;
              lastTurn = now;
            });
          }
        });
      /** Marque les entit√©s √† r√©initialiser et m√©morise leur √©tat initial */
      
      AFRAME.registerComponent('resettable', {
        init () {
          const el = this.el;
          // M√©morise local + MONDE (pour √©viter les surprises avec les parents d√©cal√©s)
          this.startLocalPos = el.object3D.position.clone();
          this.startLocalRot = el.object3D.rotation.clone();

          this.startWorldPos = new THREE.Vector3();
          this.startWorldQuat = new THREE.Quaternion();
          el.object3D.getWorldPosition(this.startWorldPos);
          el.object3D.getWorldQuaternion(this.startWorldQuat);
        },

        resetNow () {
          const el = this.el;
          const eps = 0.005; // petit lift pour √©viter l‚Äôinterp√©n√©tration

          // 1) Remettre la partie visuelle (local)
          el.object3D.position.copy(this.startLocalPos);
          el.object3D.rotation.copy(this.startLocalRot);
          el.object3D.updateMatrixWorld(true);

          // 2) Si le body physique existe, le remettre en MONDE (sinon on attend 'body-loaded')
          const applyToBody = (body) => {
            if (!body) return;
            // Position monde + petit epsilon Y
            const p = this.startWorldPos.clone(); p.y += eps;

            // ----- Cannon.js -----
            if (body.position && body.quaternion) {
              body.position.set(p.x, p.y, p.z);
              body.quaternion.set(this.startWorldQuat.x, this.startWorldQuat.y, this.startWorldQuat.z, this.startWorldQuat.w);
              if (body.velocity) body.velocity.set(0,0,0);
              if (body.angularVelocity) body.angularVelocity.set(0,0,0);
              if (body.sleep) body.sleep();
              if (body.wakeUp) body.wakeUp();
            }

            // ----- Ammo.js (aframe-physics-system l‚Äôunifie assez bien, les lignes ci-dessus suffisent souvent) -----
            try { body.activate && body.activate(); } catch(e) {}
          };

          if (el.body) {
            applyToBody(el.body);
            // Sync A-Frame -> Physique si dispo
            try { el.components['dynamic-body']?.syncToPhysics(); } catch(e) {}
          } else {
            // Le body n'est pas encore cr√©√© (rare ici) : attendre et appliquer
            el.addEventListener('body-loaded', () => applyToBody(el.body), {once:true});
          }
        }
      });

      AFRAME.registerComponent('press-button', {
        schema: { cooldown: {type: 'number', default: 400} },
        init() {
          const el = this.el;
          const base = el.object3D.position.clone();
          this.upY   = base.y;
          this.downY = this.upY - 0.02;
          this.last  = 0;

          el.setAttribute('animation__down',
            `property: position; to: ${base.x} ${this.downY} ${base.z}; dur: 70; easing: easeOutQuad; startEvents: goDown; dir: normal`);
          el.setAttribute('animation__up',
            `property: position; to: ${base.x} ${this.upY} ${base.z}; dur: 120; easing: easeOutQuad; startEvents: goUp; dir: normal`);

          const doHardReset = () => {
            const now = Date.now();
            if (now - this.last < this.data.cooldown) return;
            this.last = now;

            // 1) reset TOUT ce qui est resettable (balle + quilles‚Ä¶)
            document.querySelectorAll('[resettable]').forEach(e => e.components.resettable?.resetNow());
            // 2) pr√©venir le scorekeeper qu'on veut un "vrai" reset d'√©tat (frame=1, roll=1‚Ä¶)
            this.el.sceneEl.emit('hard-reset');
          };

          el.addEventListener('hover-start', () => { el.emit('goDown'); doHardReset(); });
          el.addEventListener('hover-end',   () => { el.emit('goUp'); });
          el.addEventListener('click',       () => { el.emit('goDown'); doHardReset(); setTimeout(() => el.emit('goUp'), 120); });
        }
      });

      AFRAME.registerComponent('score-keeper', {
        schema: {
          balls:   {type: 'selectorAll', default: '.bowling-ball'},
          pins:   {type: 'selector', default: '#pins'},
          board:  {type: 'selector', default: '#score-text'},
          settleMs:    {type: 'int',    default: 2500},
          tiltDeg:     {type: 'number', default: 25},
          speedThresh: {type: 'number', default: 0.05},
          maxFrames:   {type: 'int',    default: 10},
          ballReturnMs:{type: 'int',    default: 1800}, // retour auto pour 2e lancer
          nextFrameMs: {type: 'int',    default: 2000}  // ‚¨ÖÔ∏è d√©lai avant passage auto √† la frame suivante
        },

        init() {
          this.frame = 1;
          this.roll  = 1;
          this.fallenSet = new Set();
          this.frameComplete = false;

          this.timer = null;         // settle timer fin de lancer
          this.ballTimer = null;     // retour auto balle
          this.nextFrameTimer = null;// ‚¨ÖÔ∏è timer passage frame auto
          this.awaitingSettle = false;

          this.pinEls = Array.from(this.data.pins.querySelectorAll('a-cylinder'));
          this.pinEls.forEach((p, i) => { if (!p.dataset.idx) p.dataset.idx = String(i+1); });

          this.ballEls = Array.from(this.data.balls || []);
          this.currentBall = null; // derni√®re balle utilis√©e
          this.isRolling = false;
          this.hitAccum = 0;       // puissance max des impacts cumul√©s
          this.hitTimer = null;    // debounce pour regrouper plusieurs collisions proches

          this.queuePinHit = (powerNorm) => {
            // on garde le max (son ¬´ le plus fort ¬ª dans la rafale)
            this.hitAccum = Math.max(this.hitAccum, powerNorm);
            if (this.hitTimer) return;     // d√©j√† pr√©vu ‚Üí on attend la lecture group√©e

            this.hitTimer = setTimeout(() => {
              const b = this.currentBall;
              if (b) {
                const vol = THREE.MathUtils.clamp(0.25 + 0.75 * this.hitAccum, 0, 1); // 0.25‚Äì1.0
                b.setAttribute('sound__pins', 'volume', vol);
                b.components['sound__pins']?.playSound(); // üîä un seul son, √† la position de la balle
              }
              this.hitAccum = 0;
              this.hitTimer = null;
            }, 80); // fen√™tre (~80 ms) pour regrouper plusieurs collisions
          };


          // helper: lire vitesse (m/s)
          this.getSpeed = (el) => {
            const v = el?.body?.velocity; if (!v) return 0;
            return Math.hypot(v.x, v.y, v.z);
          };

          // helper: d√©marrer/stopper le loop de roulement
          this.updateRollingSound = () => {
            const b = this.currentBall;
            if (!b) return;
            const speed = this.getSpeed(b);

            // heuristique: sur la piste (basse altitude) et assez vite
            const onLane = (b.object3D.position.y < 0.30);
            const wantPlay = onLane && speed > 0.25;

            const roll = b.components['sound__roll'];
            if (!roll) return;

            if (wantPlay && !this.isRolling) { roll.playSound(); this.isRolling = true; }
            if (!wantPlay && this.isRolling) { roll.stopSound(); this.isRolling = false; }
          };

          // balle touche une quille -> timer de settle
          // √©coute collisions pour TOUTES les balles
          this.onBallCollide = (e) => {
            const ballEl = e.target; // la balle qui a √©mis l'event
            const other  = e.detail?.body?.el;
            if (!other) return;
            if (this.pinEls.includes(other)) {
              this.currentBall = ballEl;  // m√©morise la balle active
              // impact energy ~ masse_balle * |v|
              const v = this.getSpeed(ballEl);
              const powerNorm = THREE.MathUtils.clamp(v / 4.0, 0, 1); // ajuste 4.0 selon ta sc√®ne
              if (powerNorm > 0.1) this.queuePinHit(powerNorm);
              this.armSettleTimer();
            }
          };

          // m√©moriser la balle quand on la saisit
          this.onGrabStart = (e) => { this.currentBall = e.target; };
          this.onGrabEnd = (e) => {
            const b = e.target;
            // petit d√©lai pour laisser la physique donner sa vitesse
            setTimeout(() => {
              const speed = this.getSpeed(b);
              if (speed > 0.4) b.components['sound__throw']?.playSound();
            }, 20);
          };

          // brancher les √©couteurs sur chaque balle
          this.ballEls.forEach(b => {
            b.addEventListener('collide', this.onBallCollide);
            b.addEventListener('grab-start', this.onGrabStart); // super-hands
            b.addEventListener('grab-end',   this.onGrabEnd);
          });

          // pour tester l'immobilit√©, on regarde la balle active
          this.tick = () => {
            // rolling loop
            this.updateRollingSound();

            // logique d'√©valuation (immobilit√©)
            if (!this.awaitingSettle || !this.currentBall?.body) return;
            const speed = this.getSpeed(this.currentBall);
            if (speed < this.data.speedThresh) this.evaluateNow();
          };


          // HARD RESET (bouton) : tout l'√©tat repart √† z√©ro (comme refresh)
          this.onHardReset = () => { this.fullResetState(); };
          this.el.sceneEl.addEventListener('hard-reset', this.onHardReset);

          this.updateBoard({thisRoll: 0, totalDown: 0, tag: ''});
        },

        remove() {
          this.ballEls.forEach(b => {
            b.removeEventListener('collide', this.onBallCollide);
            b.removeEventListener('grab-start', this.onGrabStart);
          });
          this.el.sceneEl.removeEventListener('hard-reset', this.onHardReset);
          this.clearTimer();
          this.clearBallTimer();
          this.clearNextFrameTimer();
        },

        // ---- timers
        armSettleTimer() {
          this.clearTimer();
          if (this.frameComplete) return;
          this.awaitingSettle = true;
          this.timer = setTimeout(() => this.evaluateNow(), this.data.settleMs);
        },
        clearTimer()       { if (this.timer) clearTimeout(this.timer); this.timer = null; },
        clearBallTimer()   { if (this.ballTimer) clearTimeout(this.ballTimer); this.ballTimer = null; },
        clearNextFrameTimer(){ if (this.nextFrameTimer) clearTimeout(this.nextFrameTimer); this.nextFrameTimer = null; },

        // ---- posture
        isUpright(pinEl) {
          const q = new THREE.Quaternion();
          pinEl.object3D.getWorldQuaternion(q);
          const up = new THREE.Vector3(0,1,0).applyQuaternion(q);
          const angle = up.angleTo(new THREE.Vector3(0,1,0));
          const deg = THREE.MathUtils.radToDeg(angle);
          return deg < this.data.tiltDeg;
        },
        getDownPins() { return this.pinEls.filter(p => !this.isUpright(p)); },
        // Convertit une position MONDE -> LOCALE puis d√©place l'entit√© + son body
        moveEntityToWorld(el, worldPos, quat=null) {
          // partie visuelle
          const parent = el.object3D.parent;
          const local = worldPos.clone();
          if (parent) parent.worldToLocal(local);
          el.object3D.position.copy(local);
          if (quat) el.object3D.quaternion.copy(quat);
          el.object3D.updateMatrixWorld(true);

          // partie physique
          const body = el.body;
          if (body) {
            const p = worldPos.clone(); p.y += 0.002; // petit lift anti-interp√©n√©tration
            if (body.position) body.position.set(p.x, p.y, p.z);
            if (quat && body.quaternion) body.quaternion.set(quat.x, quat.y, quat.z, quat.w);
            if (body.velocity) body.velocity.set(0,0,0);
            if (body.angularVelocity) body.angularVelocity.set(0,0,0);
            try { el.components['dynamic-body']?.syncToPhysics(); } catch(e) {}
          }
        },

        // Aligne en grille derri√®re le mur les quilles tomb√©es au 1er lancer
        parkFallenPins() {
          // base MONDE derri√®re le mur (le tien est vers z‚âà-5.5)
          const base = new THREE.Vector3(1.0, 0.05, -6.2); // x‚âàaxe de la piste, z derri√®re
          const dx = 0.16, dz = 0.34;                      // entraxes de la grille
          let i = 0;
          // On utilise l'ordre stable des quilles tomb√©es
          const fallen = Array.from(this.fallenSet);
          fallen.forEach(pinEl => {
            // si finalement elle est debout (rare), on ne la range pas
            if (this.isUpright(pinEl)) return;
            const col = i % 5;         // 5 par rang√©e
            const row = (i / 5) | 0;
            const target = base.clone();
            target.x += (col - 2) * dx; // centr√© autour de la piste
            target.z -= row * dz;       // plusieurs rang√©es si besoin
            // on garde l‚Äôorientation actuelle (couch√©e) ; ou remet debout:
            // const quat = new THREE.Quaternion(); // (laisse null pour conserver)
            this.moveEntityToWorld(pinEl, target, null);
            i++;
          });
        },


        // ---- fin de lancer
        evaluateNow() {
          if (this.frameComplete) return;
          this.clearTimer();
          this.awaitingSettle = false;

          const downNow = this.getDownPins();
          const downSetNow = new Set(downNow);
          const thisRollKnocked = downNow.filter(p => !this.fallenSet.has(p)).length;
          const totalDown = new Set([...this.fallenSet, ...downSetNow]).size;

          let tag = '';
          if (this.roll === 1 && totalDown === 10) tag = 'STRIKE!';
          if (this.roll === 2 && totalDown === 10) tag = 'SPARE!';
          this.updateBoard({thisRoll: thisRollKnocked, totalDown, tag});
          const announcer = document.querySelector('#announcer');
          if (tag === 'STRIKE!') announcer?.components['sound__strike']?.playSound();
          if (tag === 'SPARE!')  announcer?.components['sound__spare']?.playSound();

          // persiste tomb√©es
          downSetNow.forEach(p => this.fallenSet.add(p));

          // avance d'√©tat + automatisme
          if (this.roll === 1) {
            if (totalDown === 10) {
              // STRIKE -> frame finie -> passage auto √† la frame suivante
              this.frameComplete = true;
              this.clearBallTimer();
              this.scheduleNextFrame();
            } else {
              // on passe au 2e lancer + retour automatique de la balle
              this.roll = 2;

               // üßπ RANGER les quilles tomb√©es du 1er lancer pour qu'elles ne g√™nent pas
              this.parkFallenPins();

              // puis retour auto de la balle
              this.scheduleBallReturn();
            }
          } else {
            // fin du 2e lancer -> frame finie -> passage auto
            this.frameComplete = true;
            this.clearBallTimer();
            this.scheduleNextFrame();
          }
        },

        // Retour auto : reset uniquement la balle "active", fallback sur la 1re si besoin
        scheduleBallReturn() {
          this.clearBallTimer();
          this.ballTimer = setTimeout(() => {
            if (this.frameComplete || this.roll !== 2) return;
            const toReset = this.currentBall || this.ballEls[0];
            toReset?.components.resettable?.resetNow();
            this.isRolling = false;
            this.currentBall?.components['sound__roll']?.stopSound();
          }, this.data.ballReturnMs);
        },

        // Passage de frame : reset toutes les balles + quilles
        scheduleNextFrame() {
          this.clearNextFrameTimer();
          this.nextFrameTimer = setTimeout(() => {
            this.isRolling = false;
            this.currentBall?.components['sound__roll']?.stopSound();
            [...document.querySelectorAll('[resettable]')].forEach(e => e.components.resettable?.resetNow());
            this.advanceFrame();
          }, this.data.nextFrameMs);
        },

        // ---- affichage
        updateBoard({thisRoll, totalDown, tag}) {
          const left = `Tour: ${this.frame}  Lancer: ${this.roll}`;
          const right = `+${thisRoll} (total ${totalDown}/10)`;
          const extra = tag ? `  ${tag}` : '';
          this.data.board.setAttribute('text', 'value', `${left} ‚Äî\n ${right}\n${extra}`);
        },

        // ---- avance d'une frame (appel√© par scheduleNextFrame)
        advanceFrame() {
          this.fallenSet.clear();
          this.frameComplete = false;
          this.roll = 1;
          this.frame += 1;
          if (this.frame > this.data.maxFrames) this.frame = 1;
          this.updateBoard({thisRoll: 0, totalDown: 0, tag: ''});
        },

        // ---- hard reset (remise √† z√©ro compl√®te de la partie)
        fullResetState() {
          this.clearTimer();
          this.clearBallTimer();
          this.clearNextFrameTimer();
          this.awaitingSettle = false;

          this.fallenSet.clear();
          this.frameComplete = false;
          this.frame = 1;
          this.roll  = 1;
          this.updateBoard({thisRoll: 0, totalDown: 0, tag: ''});
          this.isRolling = false;
          this.currentBall?.components['sound__roll']?.stopSound();
        }
      });


      // Lance la musique apr√®s le premier geste utilisateur (click / enter-vr)
      AFRAME.registerComponent('bgm-controller', {
        init() {
          const el = this.el; // l'entit√© qui porte sound__bgm
          const start = () => {
            // √©vite double start
            if (this.started) return;
            this.started = true;
            el.components['sound__bgm']?.playSound();
            window.removeEventListener('click', start);
            el.sceneEl.removeEventListener('enter-vr', start);
          };
          // un clic n'importe o√π ou l‚Äôentr√©e en VR suffisent
          window.addEventListener('click', start, { once: true });
          el.sceneEl.addEventListener('enter-vr', start, { once: true });
        }
      });

    </script>

    </head>

    <body>
      <a-scene
        shadow="type: pcfsoft"
        renderer="antialias: true"
        vr-mode-ui="enabled: true"
        device-orientation-permission-ui="enabled: true"
        physics="gravity: -9.8; debug: false"
        score-keeper="balls: .bowling-ball; pins: #pins; board: #score-text; settleMs: 2500; tiltDeg: 25">
        <!-- Assets -->
        <a-assets>

          <img id="skyTexture" src="./assets/skynet.png" />
          <img id="groundTexture" src="./assets/grass.jpg" />
          <a-asset-item id="bowlingball" src="assets/VR_Bowling_ball.glb"></a-asset-item>
          <a-asset-item id="bowlingpin" src="assets/VR_Bowling_pin.glb"></a-asset-item>
          <audio id="sfx-throw"  src="assets/sfx/throw-whoosh.mp3"></audio>
          <audio id="sfx-roll"   src="assets/sfx/ball-roll-loop.mp3"></audio>
          <audio id="sfx-pin"    src="assets/sfx/pins-hit.mp3"></audio>
          <audio id="sfx-strike" src="assets/sfx/strike.mp3"></audio>
          <audio id="sfx-spare"  src="assets/sfx/spare.mp3"></audio>
          <audio id="sfx-music" src="assets/music/bgm.mp3" crossorigin="anonymous"></audio>


        </a-assets>

        <!-- Lumi√®res -->
        <a-entity light="type: ambient; intensity: 0.4"></a-entity>
        <a-entity light="type: directional; intensity: 1; castShadow: true" position="2 4 -2"></a-entity>

        <!-- RIG + cam√©ra + contr√¥leurs -->
        <a-entity id="rig" position="1 0.2 1" joystick-movement="speed: 2" snap-turn="angle: 30; cooldown: 300">
          <a-entity id="head" camera wasd-controls-enabled="false" look-controls></a-entity>

          <!-- Mains : super-hands limit√© au bouton grip (side) + collision par sph√®re -->
          <a-entity id="leftHand"
            oculus-touch-controls="hand: left"
            super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
            sphere-collider="objects: .grabbable, .hoverable, .pressable"
            static-body="shape: sphere; sphereRadius: 0.03">
          </a-entity>

          <a-entity id="rightHand"
            oculus-touch-controls="hand: right"
            super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
            sphere-collider="objects: .grabbable, .hoverable, .pressable"
            static-body="shape: sphere; sphereRadius: 0.03">
          </a-entity>
        </a-entity>

        <!-- GROUPE : piste de bowling (version full <a-box>) + extension -->
        <a-entity id="bowling-lane" position="1 0 0">

          <!-- Approche (zone de d√©part) -->
          <a-box position="0 0.01 -0.106" width="1.066" height="0.02" depth="2"
                material="color:#c89c6c; metalness:0.2; roughness:0.7"
                static-body="shape: box"></a-box>

          <!-- Ligne de faute -->
          <a-box position="0 0.011 -1.2" width="1.066" height="0.02" depth="0.02"
                material="color:#ffffff" static-body="shape: box"></a-box>

          <!-- Piste (segment 1) -->
          <a-box position="0 0.01 -2.1" width="1.066" height="0.02" depth="2.0"
                material="color:#b38354; metalness:0.2; roughness:0.6"
                static-body="shape: box"></a-box>

          <!-- Piste (segment 2 ‚Äì extension) -->
          <!-- L‚Äôextension commence juste apr√®s le segment 1 : span [-3.9 ; -3.1] -->
          <a-box position="0 0.01 -3.5" width="1.066" height="0.02" depth="0.8"
                material="color:#b38354; metalness:0.2; roughness:0.6"
                static-body="shape: box"></a-box>

          <!-- Pin deck (recul√© derri√®re l‚Äôextension) -->
          <!-- depth=0.6 => span [-4.3 ; -3.7] -->
          <a-box position="0 0.01 -4.45" width="1.066" height="0.02" depth="2"
                material="color:#a87447; metalness:0.2; roughness:0.6"
                static-body="shape: box"></a-box>

          <!-- Goutti√®res (allong√©es jusqu‚Äôau fond) -->
          <!-- On couvre approximativement de -0.6 √† -4.3 => centre -2.45, depth 4 -->
          <a-box position="-0.68 -0.04 -2.45" width="0.28" height="0.02" depth="6"
                material="color:#6b6b6b; roughness:0.9"
                static-body="shape: box"></a-box>
          <a-box position="0.68 -0.04 -2.45" width="0.28" height="0.02" depth="6"
                material="color:#6b6b6b; roughness:0.9"
                static-body="shape: box"></a-box>

          <!-- Bordures (rails) allong√©es pareil que les goutti√®res -->
          <a-box position="-0.82 0.12 -2.45" width="0.04" height="0.24" depth="6"
                material="color:#444" static-body="shape: box"></a-box>
          <a-box position="0.82 0.12 -2.45" width="0.04" height="0.24" depth="6"
                material="color:#444" static-body="shape: box"></a-box>

          <!-- Rep√®res (points) -->
          <a-box position="-0.3 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0.3 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>

          <!-- Fl√®ches (pos√©es sur la piste) -->
          <a-box position="-0.25 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0.25 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>

          <!-- Mur de fond (recul√©) -->
          <a-box position="0 0.5 -5.5" width="1.2" height="1.0" depth="0.05"
                material="color:#222"></a-box>
        </a-entity>

        <!-- BOUTON RESET flottant, √† droite du d√©part -->
        <a-entity id="reset-station" position="1.55 0 -0.6">
          <!-- pied fin -->
          <a-box position="0 0.15 0" width="0.04" height="0.9" depth="0.04"
                material="color:#444" static-body="shape: box"></a-box>

          <!-- plateau -->
          <a-box position="0 0.61 0" width="0.20" height="0.02" depth="0.20"
                material="color:#2b2b2b" static-body="shape: box"></a-box>

          <!-- bouton enfon√ßable -->
          <a-box id="reset-button"
                class="pressable"
                hoverable
                position="0 0.63 0"
                width="0.12" height="0.03" depth="0.12"
                material="color:#e53935; emissive:#a00000; emissiveIntensity:0.4; metalness:0.2; roughness:0.5"
                press-button
                static-body="shape: box">
          </a-box>

          <!-- √©tiquette -->
          <a-entity text="value: RESET; align: center; color: #fff; width: 1.2"
                    position="0 0.67 0"></a-entity>
        </a-entity>

        <!-- Score -->
        <a-entity id="score-board" position="2 1 -2" rotation="0 -30 0">
          <a-plane width="0.7" height="0.6" color="#222" opacity="0.8"></a-plane>
          <a-entity id="score-text" text="value: Score: 0; align: center; color: #0f0; width: 1.8"
                    position="0 0 0.01"></a-entity>
        </a-entity>

        <!-- Box contenant balle facile-->
         <a-entity id="ball-box" position="-0.1 0 0.24">
           <!-- sol de la box -->
          <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                material="color:#666; metalness:0.3; roughness:0.8"
                static-body="shape: box"></a-box>
          <!-- murs de la box -->
          <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
            <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
            <a-entity text="value: Balle facile; align: center; color: #0f0; width: 1.4"
                      position="0 0 0.01"></a-entity>
          </a-entity>
        </a-entity>

        <!-- Box contenant balle moyenne-->
         <a-entity id="ball-box" position="-0.1 0 0.75">
           <!-- sol de la box -->
          <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                material="color:#666; metalness:0.3; roughness:0.8"
                static-body="shape: box"></a-box>
          <!-- murs de la box -->
          <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
            <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
            <a-entity text="value: Balle moyenne; align: center; color: #0f0; width: 1.4"
                      position="0 0 0.01"></a-entity>
          </a-entity>
        </a-entity>

        <!-- Box contenant balle difficile-->
         <a-entity id="ball-box" position="-0.1 0 1.26">
           <!-- sol de la box -->
          <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                material="color:#666; metalness:0.3; roughness:0.8"
                static-body="shape: box"></a-box>
          <!-- murs de la box -->
          <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                material="color:#444"
                static-body="shape: box"></a-box>
          <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
            <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
            <a-entity text="value: Balle difficile; align: center; color: #0f0; width: 1.4"
                      position="0 0 0.01"></a-entity>
          </a-entity>
        </a-entity>

        <!-- Disclaimer de prendre qu'une seule balle √† la fois -->
        <a-entity position="-0.413 0.976 0.983" rotation="0 90 0">
          <a-plane width="1.4" height="0.2" color="#222" opacity="0.8"></a-plane>
          <a-entity text="value: Prenez une seule balle √† la fois!; align: center; color: #f00; width: 2"
                    position="0 0 0.01"></a-entity>
        </a-entity>

        <!-- OBJETS SAISISSABLES (physiques) -->
        <!-- Boules de bowling -->

         <!-- facile -->
        <a-sphere id="ball-easy" class="bowling-ball grabbable" resettable position="-0.081 0.170 0.408" radius="0.15" color="#EF2D5E"
                  shadow="cast: true; receive: true" opacity="0"
                  grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                  dynamic-body="mass: 10; shape: sphere"
                  sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                  sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                  sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                  <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.19 0.19 0.19"></a-entity>
        </a-sphere>

          <!-- moyen -->
        <a-sphere id="ball-medium" class="bowling-ball grabbable" resettable position="-0.081 0.170 0.918" radius="0.15" color="#EF2D5E"
                  shadow="cast: true; receive: true" opacity="0"
                  grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                  dynamic-body="mass: 1; shape: sphere"
                  sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                  sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                  sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                  <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.19 0.19 0.19"></a-entity>
        </a-sphere>

          <!-- difficile -->
        <a-sphere id="ball-hard" class="bowling-ball grabbable" resettable position="-0.081 0.170 1.428" radius="0.15" color="#EF2D5E"
                  shadow="cast: true; receive: true" opacity="0"
                  grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                  dynamic-body="mass: 0.1; shape: sphere"
                  sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                  sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                  sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                  <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.19 0.19 0.19"></a-entity>
        </a-sphere>

        <!-- Quilles align√©es fa√ßon bowling (1‚Äì2‚Äì3‚Äì4) -->
        <!-- Quilles bowling resserr√©es (√©cart entre lignes r√©duit) -->
        <a-entity id="pins" rotation="0 0 0" position="0.045 0.3 -2.5">
          <a-cylinder class="grabbable" resettable position="1.0 0.1 -1.9" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.9 0.1 -2.1" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.1 0.1 -2.1" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.8 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.0 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.2 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.7 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="0.9 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.1 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.3 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
        </a-entity>

        <a-entity id="announcer"
          sound__strike="src: #sfx-strike; volume: 0.9; positional: false"
          sound__spare="src: #sfx-spare;  volume: 0.8; positional: false">
        </a-entity>

        <a-entity id="bgm"
          bgm-controller
          sound__bgm="src: #sfx-music; loop: true; positional: false; autoplay: false; volume: 0.25">
        </a-entity>

       <!-- SOL : √† y = 0 (garde shape: plane) -->
        <a-plane position="0 -0.1 -1" rotation="-90 0 0" width="100" height="100" opacity="1"
                shadow="cast: false; receive: true"
                static-body="shape: plane"></a-plane>

        <a-sky src="#skyTexture"></a-sky>
      </a-scene>
    </body>
</html>