<!DOCTYPE html>
<html>
    <head>
      <meta charset="utf-8" />
      <title>Projet WebVR</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />

      <!-- A-Frame 1.7.0 -->
      <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

      <!-- A-Frame 1.5+ : √©viter le conflit de nom "grabbable" -->
      <script> delete AFRAME.components["grabbable"]; </script> <!-- cf. super-hands -->

      <!-- aframe-extras (sphere-collider) -->
      <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

      <!-- Physics system (CANNON/Ammo support) -->
      <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

      <!-- super-hands 3.x -->
      <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

      <!-- Tes composants de d√©placement -->
      <script>
        // D√©placement joystick gauche
        AFRAME.registerComponent('joystick-movement', {
        schema: {
          speed: {type: 'number', default: 2},
          minX: {type: 'number', default: -0.78}, // murs √† x=-1 et x=3, ray. joueur ‚âà 0.22
          maxX: {type: 'number', default:  2.78},
          minZ: {type: 'number', default: -6.78}, // murs √† z=-7 et z=2
          maxZ: {type: 'number', default:  1.78}
        },
        init: function () {
          const rig = document.querySelector('#rig');
          const head = document.querySelector('#head');
          const leftHand = document.querySelector('#leftHand');
          const DEADZONE = 0.1;
          const speed = this.data.speed;
          const clamp = (v, a, b) => Math.min(Math.max(v, a), b);

          leftHand.addEventListener('thumbstickmoved', (evt) => {
            const dx = evt.detail.x, dy = evt.detail.y;
            if (Math.abs(dx) < DEADZONE && Math.abs(dy) < DEADZONE) return;

            // axes locaux (avant/droite) √† plat
            const forward = new THREE.Vector3();
            head.object3D.getWorldDirection(forward);
            forward.y = 0; forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

            // petit pas (√©vite le "tunneling")
            const step = 0.04 * speed;

            // On applique s√©par√©ment X puis Z -> "glisse" sur les murs
            const p = rig.object3D.position.clone();

            // tentative X
            const nx = p.x + (right.x * dx + forward.x * dy) * step;
            const clampedX = clamp(nx, this.data.minX, this.data.maxX);
            p.x = clampedX;

            // tentative Z
            const nz = rig.object3D.position.z + (right.z * dx + forward.z * dy) * step;
            const clampedZ = clamp(nz, this.data.minZ, this.data.maxZ);
            p.z = clampedZ;

            rig.object3D.position.copy(p);
          });
        }
      });


        // Rotation par crans (joystick droit)
        AFRAME.registerComponent('snap-turn', {
          schema: { angle: { type: 'number', default: 30 }, cooldown: { type: 'number', default: 300 } },
          init: function () {
            const rig = document.querySelector('#rig');
            const rightHand = document.querySelector('#rightHand');
            const angle = this.data.angle, cooldown = this.data.cooldown;
            let lastTurn = 0;
            rightHand.addEventListener('thumbstickmoved', function (evt) {
              const now = Date.now(), x = evt.detail.x;
              if (Math.abs(x) < 0.8 || now - lastTurn < cooldown) return;
              const rad = THREE.MathUtils.degToRad(angle);
              if (x > 0.8)  rig.object3D.rotation.y -= rad;
              else          rig.object3D.rotation.y += rad;
              lastTurn = now;
            });
          }
        });
      /** Marque les entit√©s √† r√©initialiser et m√©morise leur √©tat initial */
      
      AFRAME.registerComponent('resettable', {
        init () {
          const el = this.el;
          // M√©morise local + MONDE (pour √©viter les surprises avec les parents d√©cal√©s)
          this.startLocalPos = el.object3D.position.clone();
          this.startLocalRot = el.object3D.rotation.clone();

          this.startWorldPos = new THREE.Vector3();
          this.startWorldQuat = new THREE.Quaternion();
          el.object3D.getWorldPosition(this.startWorldPos);
          el.object3D.getWorldQuaternion(this.startWorldQuat);
        },

        resetNow () {
          const el = this.el;
          const eps = 0.005; // petit lift pour √©viter l‚Äôinterp√©n√©tration

          // 1) Remettre la partie visuelle (local)
          el.object3D.position.copy(this.startLocalPos);
          el.object3D.rotation.copy(this.startLocalRot);
          el.object3D.updateMatrixWorld(true);

          // 2) Si le body physique existe, le remettre en MONDE (sinon on attend 'body-loaded')
          const applyToBody = (body) => {
            if (!body) return;
            // Position monde + petit epsilon Y
            const p = this.startWorldPos.clone(); p.y += eps;

            // ----- Cannon.js -----
            if (body.position && body.quaternion) {
              body.position.set(p.x, p.y, p.z);
              body.quaternion.set(this.startWorldQuat.x, this.startWorldQuat.y, this.startWorldQuat.z, this.startWorldQuat.w);
              if (body.velocity) body.velocity.set(0,0,0);
              if (body.angularVelocity) body.angularVelocity.set(0,0,0);
              if (body.sleep) body.sleep();
              if (body.wakeUp) body.wakeUp();
            }

            // ----- Ammo.js (aframe-physics-system l‚Äôunifie assez bien, les lignes ci-dessus suffisent souvent) -----
            try { body.activate && body.activate(); } catch(e) {}
          };

          if (el.body) {
            applyToBody(el.body);
            // Sync A-Frame -> Physique si dispo
            try { el.components['dynamic-body']?.syncToPhysics(); } catch(e) {}
          } else {
            // Le body n'est pas encore cr√©√© (rare ici) : attendre et appliquer
            el.addEventListener('body-loaded', () => applyToBody(el.body), {once:true});
          }
        }
      });

      AFRAME.registerComponent('press-button', {
        schema: { cooldown: {type: 'number', default: 400} },
        init() {
          const el = this.el;
          const base = el.object3D.position.clone();
          this.upY   = base.y;
          this.downY = this.upY - 0.02;
          this.last  = 0;

          el.setAttribute('animation__down',
            `property: position; to: ${base.x} ${this.downY} ${base.z}; dur: 70; easing: easeOutQuad; startEvents: goDown; dir: normal`);
          el.setAttribute('animation__up',
            `property: position; to: ${base.x} ${this.upY} ${base.z}; dur: 120; easing: easeOutQuad; startEvents: goUp; dir: normal`);

          const doHardReset = () => {
            const now = Date.now();
            if (now - this.last < this.data.cooldown) return;
            this.last = now;

            // 1) reset TOUT ce qui est resettable (balle + quilles‚Ä¶)
            document.querySelectorAll('[resettable]').forEach(e => e.components.resettable?.resetNow());
            // 2) pr√©venir le scorekeeper qu'on veut un "vrai" reset d'√©tat (frame=1, roll=1‚Ä¶)
            this.el.sceneEl.emit('hard-reset');
          };

          el.addEventListener('hover-start', () => { el.emit('goDown'); doHardReset(); });
          el.addEventListener('hover-end',   () => { el.emit('goUp'); });
          el.addEventListener('click',       () => { el.emit('goDown'); doHardReset(); setTimeout(() => el.emit('goUp'), 120); });
        }
      });

      AFRAME.registerComponent('score-keeper', {
        schema: {
          balls:   {type: 'selectorAll', default: '.bowling-ball'},
          pins:    {type: 'selector', default: '#pins'},
          board:   {type: 'selector', default: '#score-text'},
          settleMs:{type: 'int',    default: 2500},
          tiltDeg: {type: 'number', default: 25},
          speedThresh: {type: 'number', default: 0.05},
          maxFrames:   {type: 'int',    default: 10},
          ballReturnMs:{type: 'int',    default: 1800}, // retour auto pour 2e lancer
          nextFrameMs: {type: 'int',    default: 2000}  // d√©lai avant passage auto √† la frame suivante
        },

        init() {
          this.frame = 1;
          this.roll  = 1;
          this.fallenSet = new Set();
          this.frameComplete = false;

          this.timer = null;         // settle timer fin de lancer
          this.ballTimer = null;     // retour auto balle
          this.nextFrameTimer = null;// timer passage frame auto
          this.awaitingSettle = false;

          this.pinEls = Array.from(this.data.pins.querySelectorAll('a-cylinder'));
          this.pinEls.forEach((p, i) => { if (!p.dataset.idx) p.dataset.idx = String(i+1); });

          // --- [AJOUT] m√©morise les filtres de collision initiaux des quilles ---
          this.pinFilterDefaults = new WeakMap();
          this.pinEls.forEach(p => {
            const stash = () => {
              const b = p.body;
              if (!b) return;
              this.pinFilterDefaults.set(p, {
                group: b.collisionFilterGroup,
                mask:  b.collisionFilterMask
              });
            };
            if (p.body) stash();
            else p.addEventListener('body-loaded', stash, {once:true});
          });

          this.ballEls = Array.from(this.data.balls || []);
          this.currentBall = null; // derni√®re balle utilis√©e
          this.isRolling = false;
          this.hitAccum = 0;       // puissance max des impacts cumul√©s
          this.hitTimer = null;    // debounce pour regrouper plusieurs collisions proches

          this.queuePinHit = (powerNorm) => {
            // on garde le max (son ¬´ le plus fort ¬ª dans la rafale)
            this.hitAccum = Math.max(this.hitAccum, powerNorm);
            if (this.hitTimer) return;     // d√©j√† pr√©vu ‚Üí on attend la lecture group√©e
            this.hitTimer = setTimeout(() => {
              const b = this.currentBall;
              if (b) {
                const vol = THREE.MathUtils.clamp(0.25 + 0.75 * this.hitAccum, 0, 1); // 0.25‚Äì1.0
                b.setAttribute('sound__pins', 'volume', vol);
                b.components['sound__pins']?.playSound(); // üîä un seul son, √† la position de la balle
              }
              this.hitAccum = 0;
              this.hitTimer = null;
            }, 80); // fen√™tre (~80 ms) pour regrouper plusieurs collisions
          };

          // helper: lire vitesse (m/s)
          this.getSpeed = (el) => {
            const v = el?.body?.velocity; if (!v) return 0;
            return Math.hypot(v.x, v.y, v.z);
          };

          // helper: d√©marrer/stopper le loop de roulement
          this.updateRollingSound = () => {
            const b = this.currentBall;
            if (!b) return;
            const speed = this.getSpeed(b);

            // heuristique: sur la piste (basse altitude) et assez vite
            const onLane = (b.object3D.position.y < 0.30);
            const wantPlay = onLane && speed > 0.25;

            const roll = b.components['sound__roll'];
            if (!roll) return;

            if (wantPlay && !this.isRolling) { roll.playSound(); this.isRolling = true; }
            if (!wantPlay && this.isRolling) { roll.stopSound(); this.isRolling = false; }
          };

          // balle touche une quille -> timer de settle
          // √©coute collisions pour TOUTES les balles
          this.onBallCollide = (e) => {
            const ballEl = e.target; // la balle qui a √©mis l'event
            const other  = e.detail?.body?.el;
            if (!other) return;
            if (this.pinEls.includes(other)) {
              this.currentBall = ballEl;  // m√©morise la balle active
              // impact energy ~ masse_balle * |v|
              const v = this.getSpeed(ballEl);
              const powerNorm = THREE.MathUtils.clamp(v / 4.0, 0, 1); // ajuste 4.0 selon ta sc√®ne
              if (powerNorm > 0.1) this.queuePinHit(powerNorm);
              this.armSettleTimer();
            }
          };

          // m√©moriser la balle quand on la saisit
          this.onGrabStart = (e) => { this.currentBall = e.target; };
          this.onGrabEnd = (e) => {
            const b = e.target;
            // petit d√©lai pour laisser la physique donner sa vitesse
            setTimeout(() => {
              const speed = this.getSpeed(b);
              if (speed > 0.4) b.components['sound__throw']?.playSound();
            }, 20);
          };

          // brancher les √©couteurs sur chaque balle
          this.ballEls.forEach(b => {
            b.addEventListener('collide', this.onBallCollide);
            b.addEventListener('grab-start', this.onGrabStart); // super-hands
            b.addEventListener('grab-end',   this.onGrabEnd);
          });

          // pour tester l'immobilit√©, on regarde la balle active
          this.tick = () => {
            // rolling loop
            this.updateRollingSound();

            // logique d'√©valuation (immobilit√©)
            if (!this.awaitingSettle || !this.currentBall?.body) return;
            const speed = this.getSpeed(this.currentBall);
            if (speed < this.data.speedThresh) this.evaluateNow();
          };

          // HARD RESET (bouton) : tout l'√©tat repart √† z√©ro (comme refresh)
          this.onHardReset = () => { this.fullResetState(); };
          this.el.sceneEl.addEventListener('hard-reset', this.onHardReset);

          this.updateBoard({thisRoll: 0, totalDown: 0, tag: ''});
        },

        remove() {
          this.ballEls.forEach(b => {
            b.removeEventListener('collide', this.onBallCollide);
            b.removeEventListener('grab-start', this.onGrabStart);
          });
          this.el.sceneEl.removeEventListener('hard-reset', this.onHardReset);
          this.clearTimer();
          this.clearBallTimer();
          this.clearNextFrameTimer();
        },

        // ---- timers
        armSettleTimer() {
          this.clearTimer();
          if (this.frameComplete) return;
          this.awaitingSettle = true;
          this.timer = setTimeout(() => this.evaluateNow(), this.data.settleMs);
        },
        clearTimer()         { if (this.timer) clearTimeout(this.timer); this.timer = null; },
        clearBallTimer()     { if (this.ballTimer) clearTimeout(this.ballTimer); this.ballTimer = null; },
        clearNextFrameTimer(){ if (this.nextFrameTimer) clearTimeout(this.nextFrameTimer); this.nextFrameTimer = null; },

        // ---- posture
        isUpright(pinEl) {
          const q = new THREE.Quaternion();
          pinEl.object3D.getWorldQuaternion(q);
          const up = new THREE.Vector3(0,1,0).applyQuaternion(q);
          const angle = up.angleTo(new THREE.Vector3(0,1,0));
          const deg = THREE.MathUtils.radToDeg(angle);
          return deg < this.data.tiltDeg;
        },
        getDownPins() { return this.pinEls.filter(p => !this.isUpright(p)); },

        // Convertit une position MONDE -> LOCALE puis d√©place l'entit√© + son body
        moveEntityToWorld(el, worldPos, quat=null) {
          // partie visuelle
          const parent = el.object3D.parent;
          const local = worldPos.clone();
          if (parent) parent.worldToLocal(local);
          el.object3D.position.copy(local);
          if (quat) el.object3D.quaternion.copy(quat);
          el.object3D.updateMatrixWorld(true);

          // partie physique
          const body = el.body;
          if (body) {
            const p = worldPos.clone(); p.y += 0.002; // petit lift anti-interp√©n√©tration
            if (body.position) body.position.set(p.x, p.y, p.z);
            if (quat && body.quaternion) body.quaternion.set(quat.x, quat.y, quat.z, quat.w);
            if (body.velocity) body.velocity.set(0,0,0);
            if (body.angularVelocity) body.angularVelocity.set(0,0,0);
            try { el.components['dynamic-body']?.syncToPhysics(); } catch(e) {}
          }
        },

        // --- [AJOUT] rendre une quille traversable (aucun contact/√©v√©nement)
        ghostifyPin(pinEl) {
          const b = pinEl.body; if (!b) return;
          b.collisionResponse = false;
          b.collisionFilterMask = 0; // collide avec rien
          if (b.velocity) b.velocity.set(0,0,0);
          if (b.angularVelocity) b.angularVelocity.set(0,0,0);
        },

        // --- [AJOUT] restaurer les collisions d‚Äôune quille
        restorePin(pinEl) {
          const b = pinEl.body; if (!b) return;
          const def = this.pinFilterDefaults.get(pinEl);
          if (def) {
            b.collisionFilterGroup = def.group;
            b.collisionFilterMask  = def.mask;
          } else {
            // fallback : tout autoriser
            b.collisionFilterGroup = 1;
            b.collisionFilterMask  = -1;
          }
          b.collisionResponse = true;
        },

        // --- [AJOUT] restaurer toutes les quilles
        restoreAllPins() {
          this.pinEls.forEach(p => this.restorePin(p));
        },

        // Aligne en grille derri√®re le mur les quilles tomb√©es au 1er lancer
        parkFallenPins() {
          // base MONDE derri√®re le mur (le tien est vers z‚âà-5.5)
          const base = new THREE.Vector3(1.0, 0.05, -6.2); // x‚âàaxe de la piste, z derri√®re
          const dx = 0.16, dz = 0.34;                      // entraxes de la grille
          let i = 0;
          // On utilise l'ordre stable des quilles tomb√©es
          const fallen = Array.from(this.fallenSet);
          fallen.forEach(pinEl => {
            // si finalement elle est debout (rare), on ne la range pas
            if (this.isUpright(pinEl)) return;
            const col = i % 5;         // 5 par rang√©e
            const row = (i / 5) | 0;
            const target = base.clone();
            target.x += (col - 2) * dx; // centr√© autour de la piste
            target.z -= row * dz;       // plusieurs rang√©es si besoin
            // on garde l‚Äôorientation actuelle (couch√©e) ; ou remet debout:
            // const quat = new THREE.Quaternion(); // (laisse null pour conserver)
            this.moveEntityToWorld(pinEl, target, null);
            i++;

            // --- [AJOUT] quille rang√©e = quille "fant√¥me"
            this.ghostifyPin(pinEl);
          });
        },

        // ---- fin de lancer
        evaluateNow() {
        if (this.frameComplete) return;
        this.clearTimer();
        this.awaitingSettle = false;

        const downNow = this.getDownPins();
        const downSetNow = new Set(downNow);
        const thisRollKnocked = downNow.filter(p => !this.fallenSet.has(p)).length;
        const totalDown = new Set([...this.fallenSet, ...downSetNow]).size;

        let tag = '';
        if (this.roll === 1 && totalDown === 10) tag = 'STRIKE!';
        if (this.roll === 2 && totalDown === 10) tag = 'SPARE!';
        this.updateBoard({thisRoll: thisRollKnocked, totalDown, tag});
        const announcer = document.querySelector('#announcer');
        if (tag === 'STRIKE!') announcer?.components['sound__strike']?.playSound();
        if (tag === 'SPARE!')  announcer?.components['sound__spare']?.playSound();

        // persiste tomb√©es
        downSetNow.forEach(p => this.fallenSet.add(p));

        // --- NEW: pr√©venir le tableau de score ---
        this.el.sceneEl.emit('score:roll', {
          pins: thisRollKnocked,
          frame: this.frame,
          roll:  this.roll
        });

        // avance d'√©tat + automatisme
        if (this.roll === 1) {
          if (totalDown === 10) {
            // STRIKE -> frame finie -> passage auto √† la frame suivante
            this.frameComplete = true;
            this.clearBallTimer();
            this.scheduleNextFrame();
          } else {
            // on passe au 2e lancer
            this.roll = 2;
            // retour auto de la balle
            this.scheduleBallReturn();
            // üßπ ranger les quilles tomb√©es du 1er lancer
            this.parkFallenPins();
          }
        } else {
          // fin du 2e lancer -> frame finie -> passage auto
          this.frameComplete = true;
          this.clearBallTimer();
          this.scheduleNextFrame();
        }
      },


        // Retour auto : reset uniquement la balle "active", fallback sur la 1re si besoin
        scheduleBallReturn() {
          this.clearBallTimer();
          this.ballTimer = setTimeout(() => {
            if (this.frameComplete || this.roll !== 2) return;
            const toReset = this.currentBall || this.ballEls[0];
            toReset?.components.resettable?.resetNow();
            this.isRolling = false;
            this.currentBall?.components['sound__roll']?.stopSound();
          }, this.data.ballReturnMs);
        },

        // Passage de frame : reset toutes les balles + quilles
        scheduleNextFrame() {
          this.clearNextFrameTimer();
          this.nextFrameTimer = setTimeout(() => {
            this.isRolling = false;
            this.currentBall?.components['sound__roll']?.stopSound();

            // --- [AJOUT] r√©active les collisions des quilles pour la prochaine frame ---
            this.restoreAllPins();

            // reset visuel/physique
            [...document.querySelectorAll('[resettable]')].forEach(e => e.components.resettable?.resetNow());
            this.advanceFrame();
          }, this.data.nextFrameMs);
        },

        // ---- affichage
        updateBoard({thisRoll, totalDown, tag}) {
          const left = `Tour: ${this.frame}  Lancer: ${this.roll}`;
          const right = `+${thisRoll} (total ${totalDown}/10)`;
          const extra = tag ? `  ${tag}` : '';
          this.data.board.setAttribute('text', 'value', `${left} ‚Äî\n ${right}\n${extra}`);
        },

        // ---- avance d'une frame (appel√© par scheduleNextFrame)
        advanceFrame() {
          this.fallenSet.clear();
          this.frameComplete = false;
          this.roll = 1;
          this.frame += 1;
          if (this.frame > this.data.maxFrames) this.frame = 1;
          this.updateBoard({thisRoll: 0, totalDown: 0, tag: ''});
        },

        // ---- hard reset (remise √† z√©ro compl√®te de la partie)
        fullResetState() {
          this.clearTimer();
          this.clearBallTimer();
          this.clearNextFrameTimer();
          this.awaitingSettle = false;

          this.fallenSet.clear();
          this.frameComplete = false;
          this.frame = 1;
          this.roll  = 1;

          // --- [AJOUT] en cas de RESET : on remet les quilles "normales"
          this.restoreAllPins();

          this.updateBoard({thisRoll: 0, totalDown: 0, tag: ''});
          this.isRolling = false;
          this.currentBall?.components['sound__roll']?.stopSound();
        }
      });



      // Lance la musique apr√®s le premier geste utilisateur (click / enter-vr)
      AFRAME.registerComponent('bgm-controller', {
        init() {
          const el = this.el; // l'entit√© qui porte sound__bgm
          const start = () => {
            // √©vite double start
            if (this.started) return;
            this.started = true;
            el.components['sound__bgm']?.playSound();
            window.removeEventListener('click', start);
            el.sceneEl.removeEventListener('enter-vr', start);
          };
          // un clic n'importe o√π ou l‚Äôentr√©e en VR suffisent
          window.addEventListener('click', start, { once: true });
          el.sceneEl.addEventListener('enter-vr', start, { once: true });
        }
      });

      /**
       * bowling-scoreboard
       * - G√©n√®re une grille 10 frames.
       * - √âcoute les events :
       *   - 'score:roll'  => { pins, frame, roll }  (√©mis par score-keeper apr√®s chaque lancer)
       *   - 'hard-reset'  => r√©initialise tout
       * - Calcule les scores cumul√©s en appliquant les r√®gles bowling (strike/spare).
       */
      AFRAME.registerComponent('bowling-scoreboard', {
        schema: {
          cols:  {type: 'int', default: 10},
          cellW: {type: 'number', default: 0.18},
          cellH: {type: 'number', default: 0.10},
          gap:   {type: 'number', default: 0.006}
        },

        init() {
          this.rolls = [];            // tableau de valeurs par lancer (0..10)
          this.framesView = [];       // [{r1:'', r2:'', r3:''?, cum:''}, ...]
          this.cells = [];            // r√©f√©rences UI par frame : {r1,r2,r3,cum,box}

          this.buildGrid();

          // √©coute les √©v√©nements
          this.onRoll = (e) => {
            const pins = Math.max(0, Math.min(10, (e.detail?.pins ?? 0)));
            this.rolls.push(pins);
            this.refresh();
          };
          this.onHardReset = () => { this.resetAll(); };

          this.el.sceneEl.addEventListener('score:roll',  this.onRoll);
          this.el.sceneEl.addEventListener('hard-reset',  this.onHardReset);

          // init
          this.resetAll();
        },

        remove() {
          this.el.sceneEl.removeEventListener('score:roll',  this.onRoll);
          this.el.sceneEl.removeEventListener('hard-reset',  this.onHardReset);
        },

        resetAll() {
          this.rolls = [];
          this.framesView = Array.from({length: this.data.cols}, _ => ({r1:'', r2:'', r3:'', cum:''}));
          this.render();
        },

        buildGrid() {
          const {cols, cellW, cellH, gap} = this.data;
          const totalW = cols * cellW + (cols - 1) * gap;
          const totalH = cellH * 2 + gap; // ligne lancers (haut) + ligne cumul (bas)

          // fond
          const bg = document.createElement('a-plane');
          bg.setAttribute('width',  totalW + 0.04);
          bg.setAttribute('height', totalH + 0.04);
          bg.setAttribute('color', '#111');
          bg.setAttribute('opacity', 0.85);
          this.el.appendChild(bg);

          this.cells = [];

          // cr√©er 10 colonnes (frames)
          const startX = -totalW / 2 + cellW/2;
          const topY   =  totalH / 2 - cellH/2;

          for (let i = 0; i < cols; i++) {
            const colX = startX + i * (cellW + gap);

            // cadre de la frame
            const box = document.createElement('a-plane');
            box.setAttribute('position', `${colX} 0 0.001`);
            box.setAttribute('width',  cellW);
            box.setAttribute('height', totalH);
            box.setAttribute('color', '#222');
            box.setAttribute('opacity', 0.95);
            this.el.appendChild(box);

            // s√©parateur horizontal (entre lancers et cumul)
            const sep = document.createElement('a-plane');
            sep.setAttribute('position', `${colX} ${topY - (cellH + gap/2)} 0.002`);
            sep.setAttribute('width', cellW);
            sep.setAttribute('height', 0.003);
            sep.setAttribute('color', '#555');
            this.el.appendChild(sep);

            // en-t√™te num√©ro de frame
            const head = document.createElement('a-entity');
            head.setAttribute('position', `${colX} ${topY + 0.07} 0.003`);
            head.setAttribute('text', {
              value: String(i+1),
              align: 'center',
              color: '#9ad',
              width: 1.4
            });
            this.el.appendChild(head);

            // cases texte : r1 r2 (et r3 pour la 10e), cum
            const r1 = document.createElement('a-entity');
            r1.setAttribute('position', `${colX - cellW*0.22} ${topY} 0.003`);
            r1.setAttribute('text', {value:'', align:'center', color:'#fff', width:1.8});
            const r2 = document.createElement('a-entity');
            r2.setAttribute('position', `${colX + cellW*0.10} ${topY} 0.003`);
            r2.setAttribute('text', {value:'', align:'center', color:'#fff', width:1.8});
            const r3 = document.createElement('a-entity');
            r3.setAttribute('position', `${colX + cellW*0.35} ${topY} 0.003`);
            r3.setAttribute('text', {value:'', align:'center', color:'#fff', width:1.8, opacity: (i===9)?1:0}); // visible 10e frame

            const cum = document.createElement('a-entity');
            cum.setAttribute('position', `${colX} ${-totalH/2 + cellH/2} 0.003`);
            cum.setAttribute('text', {value:'', align:'center', color:'#0f0', width:1.6});

            this.el.appendChild(r1);
            this.el.appendChild(r2);
            this.el.appendChild(r3);
            this.el.appendChild(cum);

            this.cells.push({box, r1, r2, r3, cum});
          }
        },

        // Convertit une valeur de lancer -> symbole bowling ('X', '/', '-', chiffre)
        symbolFor(rollVal, prevRollVal=null, isTenth=false, isFirst=false) {
          if (rollVal === 10 && (isFirst || isTenth)) return 'X';
          if (rollVal === 0) return '-';
          if (prevRollVal != null && prevRollVal + rollVal === 10 && !isFirst) return '/';
          return String(rollVal);
        },

        // Calcule toutes les frames + cumul √† partir de this.rolls
        computeFrames() {
          const frames = [];
          let i = 0;
          for (let f = 1; f <= 10; f++) {
            if (f < 10) {
              const r1 = this.rolls[i]  ?? null;
              const strike = (r1 === 10);
              if (strike) {
                const bonus1 = this.rolls[i+1] ?? 0;
                const bonus2 = this.rolls[i+2] ?? 0;
                const score  = 10 + bonus1 + bonus2;
                frames.push({r1:10, r2:null, r3:null, score, kind:'X'});
                i += 1;
              } else {
                const r2 = this.rolls[i+1] ?? null;
                if (r1 == null || r2 == null) {
                  frames.push({r1, r2, r3:null, score:null, kind:'open'});
                  break; // frame incompl√®te
                }
                const sum = r1 + r2;
                if (sum === 10) {
                  const bonus = this.rolls[i+2] ?? 0;
                  frames.push({r1, r2, r3:null, score:10 + bonus, kind:'/'});
                } else {
                  frames.push({r1, r2, r3:null, score:sum, kind:'open'});
                }
                i += 2;
              }
            } else {
              // 10e frame : jusqu'√† 3 lancers
              const r1 = this.rolls[i]   ?? null;
              const r2 = this.rolls[i+1] ?? null;
              let r3 = null;
              if (r1 != null && r2 != null) {
                const strikeOrSpare = (r1 === 10) || (r1 + r2 === 10);
                if (strikeOrSpare) r3 = this.rolls[i+2] ?? null;
              }

              // score de la 10e = somme des lancers pr√©sents
              const score = [r1, r2, r3].reduce((s,v)=>s+(v??0),0);
              frames.push({r1, r2, r3, score: (r1!=null && r2!=null ? score : null), kind:'tenth'});
              // pas d'incr√©ment d'i ici : fin de parcours
            }
          }

          // cumul
          let running = 0;
          for (let k = 0; k < frames.length; k++) {
            if (frames[k].score != null) {
              running += frames[k].score;
              frames[k].cum = running;
            } else {
              frames[k].cum = null;
            }
          }
          return frames;
        },

        refresh() {
          this.framesView = this.computeFrames();
          this.render();
        },

        render() {
          // efface style actif
          this.cells.forEach((c, idx) => {
            c.box.setAttribute('color', idx === this.activeFrameIndex()? '#333' : '#222');
          });

          // met √† jour les 10 frames
          for (let f = 0; f < 10; f++) {
            const cell = this.cells[f];
            const data = this.framesView[f] || {r1:'', r2:'', r3:'', cum:''};

            // Lancers -> symboles
            if (f < 9) {
              const r1v = (data.r1 ?? null);
              const r2v = (data.r2 ?? null);
              const r1s = (r1v==null) ? '' : this.symbolFor(r1v, null, false, true);
              const r2s = (r2v==null) ? '' : this.symbolFor(r2v, r1v, false, false);
              cell.r1.setAttribute('text', 'value', r1s);
              cell.r2.setAttribute('text', 'value', r2s);
              cell.r3.setAttribute('text', 'value', '');
              cell.r3.setAttribute('text', 'opacity', 0);
            } else {
              // 10e frame (peut afficher 3 symboles)
              const r1v = (data.r1 ?? null);
              const r2v = (data.r2 ?? null);
              const r3v = (data.r3 ?? null);
              const r1s = (r1v==null) ? '' : this.symbolFor(r1v, null, true, true);
              const r2s = (r2v==null) ? '' : this.symbolFor(r2v, r1v, true, false);
              // Pour r3, l‚Äôindicateur de spare se fait par rapport √† r2 uniquement si r1 != 10 et r1+r2 == 10,
              // sinon symbole standard (X/-/nombre).
              let r3s = '';
              if (r3v != null) {
                if (r1v !== 10 && r1v != null && r2v != null && (r1v + r2v === 10)) {
                  // bonus apr√®s spare -> r3 affich√© normalement (X/-/num)
                  r3s = this.symbolFor(r3v, null, true, true);
                } else {
                  r3s = this.symbolFor(r3v, r2v, true, false);
                }
              }
              cell.r1.setAttribute('text', 'value', r1s);
              cell.r2.setAttribute('text', 'value', r2s);
              cell.r3.setAttribute('text', 'value', r3s);
              cell.r3.setAttribute('text', 'opacity', 1);
            }

            // Cumul
            const cumTxt = (data.cum == null) ? '' : String(data.cum);
            cell.cum.setAttribute('text', 'value', cumTxt);
          }
        },

        // essaie de rep√©rer la frame en cours pour surligner
        activeFrameIndex() {
          // Compte frames compl√®tes √† partir des lancers
          let i = 0, frameIdx = 0;
          for (; frameIdx < 9 && i < this.rolls.length; frameIdx++) {
            if (this.rolls[i] === 10) i += 1; else i += 2;
            if (i > this.rolls.length) break;
          }
          return Math.min(frameIdx, 9);
        }
      });

    </script>

    </head>

    <body>
      <a-scene
        shadow="type: pcfsoft"
        renderer="antialias: true"
        vr-mode-ui="enabled: true"
        device-orientation-permission-ui="enabled: true"
        physics="gravity: -9.8; debug: false"
        score-keeper="balls: .bowling-ball; pins: #pins; board: #score-text; settleMs: 2000; tiltDeg: 25">
        <!-- Assets -->
        <a-assets>

          <img id="skyTexture" src="./assets/skynet.png" />
          <img id="groundTexture" src="./assets/grass.jpg" />
          <a-asset-item id="bowlingball" src="assets/VR_Bowling_ball.glb"></a-asset-item>
          <a-asset-item id="bowlingpin" src="assets/VR_Bowling_pin.glb"></a-asset-item>
          <a-asset-item id="terrainModel" src="assets/VR_Forest.glb"></a-asset-item>
          <a-asset-item id="tung" src="assets/VR_Tung.glb"></a-asset-item>
          <audio id="sfx-throw"  src="assets/sfx/throw-whoosh.mp3"></audio>
          <audio id="sfx-roll"   src="assets/sfx/ball-roll-loop.mp3"></audio>
          <audio id="sfx-pin"    src="assets/sfx/pins-hit.mp3"></audio>
          <audio id="sfx-strike" src="assets/sfx/strike.mp3"></audio>
          <audio id="sfx-spare"  src="assets/sfx/spare.mp3"></audio>
          <audio id="sfx-music" src="assets/sfx/bgm.mp3" crossorigin="anonymous"></audio>


        </a-assets>

        <!-- Lumi√®res -->
        <a-entity light="type: ambient; intensity: 0.4"></a-entity>
        <a-entity light="type: directional; intensity: 1; castShadow: true" position="-104.569 40.500 467.632"></a-entity>

        <!-- RIG + cam√©ra + contr√¥leurs -->
        <a-entity id="rig" position="1 0.2 1" joystick-movement="speed: 2; minX: -0.78; maxX: 2.78; minZ: -6.78; maxZ: 1.78" snap-turn="angle: 30; cooldown: 300">
          <a-entity id="head" camera wasd-controls-enabled="false" look-controls></a-entity>

          <!-- Mains : super-hands limit√© au bouton grip (side) + collision par sph√®re -->
          <a-entity id="leftHand"
            oculus-touch-controls="hand: left"
            super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
            sphere-collider="objects: .grabbable, .hoverable, .pressable"
            static-body="shape: sphere; sphereRadius: 0.03">
          </a-entity>

          <a-entity id="rightHand"
            oculus-touch-controls="hand: right"
            super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
            sphere-collider="objects: .grabbable, .hoverable, .pressable"
            static-body="shape: sphere; sphereRadius: 0.03">
          </a-entity>
        </a-entity>

        <!-- Terrain -->
        <a-entity id="terrain"
                  position="-1.710 -0.100 -6.310" rotation="0 90 0" scale="1 1 1"
                  gltf-model="#terrainModel"
                  material="side: double; roughness: 1; metalness: 0"
                  static-body="shape: hull"
                  shadow="receive: true; cast: false">
        </a-entity>

        <!-- GROUPE : piste de bowling (version full <a-box>) + extension -->
        <a-entity id="bowling-lane" position="1 0 0">

          <!-- Approche (zone de d√©part) -->
          <a-box position="0 0.01 -0.106" width="1.066" height="0.02" depth="2"
                material="color:#c89c6c; metalness:0.2; roughness:0.7"
                shadow="cast: true; receive: true"
                static-body="shape: box"></a-box>

          <!-- Ligne de faute -->
          <a-box position="0 0.011 -1.2" width="1.066" height="0.02" depth="0.02"
                material="color:#ffffff" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Piste (segment 1) -->
          <a-box position="0 0.01 -2.1" width="1.066" height="0.02" depth="2.0"
                material="color:#b38354; metalness:0.2; roughness:0.6"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Piste (segment 2 ‚Äì extension) -->
          <!-- L‚Äôextension commence juste apr√®s le segment 1 : span [-3.9 ; -3.1] -->
          <a-box position="0 0.01 -3.5" width="1.066" height="0.02" depth="0.8"
                material="color:#b38354; metalness:0.2; roughness:0.6"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Pin deck (recul√© derri√®re l‚Äôextension) -->
          <!-- depth=0.6 => span [-4.3 ; -3.7] -->
          <a-box position="0 0.01 -4.45" width="1.066" height="0.02" depth="2"
                material="color:#a87447; metalness:0.2; roughness:0.6"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Goutti√®res (allong√©es jusqu‚Äôau fond) -->
          <!-- On couvre approximativement de -0.6 √† -4.3 => centre -2.45, depth 4 -->
          <a-box position="-0.68 -0.04 -2.45" width="0.28" height="0.02" depth="6"
                material="color:#6b6b6b; roughness:0.9"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>
          <a-box position="0.68 -0.04 -2.45" width="0.28" height="0.02" depth="6"
                material="color:#6b6b6b; roughness:0.9"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Bordures (rails) allong√©es pareil que les goutti√®res -->
          <a-box position="-0.82 0.12 -2.45" width="0.04" height="0.24" depth="6"
                material="color:#444" static-body="shape: box" shadow="cast: true; receive: true"></a-box>
          <a-box position="0.82 0.12 -2.45" width="0.04" height="0.24" depth="6"
                material="color:#444" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Rep√®res (points) -->
          <a-box position="-0.3 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0.3 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>

          <!-- Fl√®ches (pos√©es sur la piste) -->
          <a-box position="-0.25 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0.25 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>

          <!-- Mur de fond (recul√©) -->
          <a-box position="0 0.5 -5.5" width="1.2" height="1.0" depth="0.05"
                material="color:#222" shadow="cast: true; receive: true"></a-box>
        </a-entity>

        <!-- BOUTON RESET flottant, √† droite du d√©part -->
        <a-entity id="reset-station" position="1.55 0 -0.6">
          <!-- pied fin -->
          <a-box position="0 0.15 0" width="0.04" height="0.9" depth="0.04"
                material="color:#444" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- plateau -->
          <a-box position="0 0.61 0" width="0.20" height="0.02" depth="0.20"
                material="color:#2b2b2b" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- bouton enfon√ßable -->
          <a-box id="reset-button"
                class="pressable"
                hoverable
                position="0 0.63 0"
                width="0.12" height="0.03" depth="0.12"
                material="color:#e53935; emissive:#a00000; emissiveIntensity:0.4; metalness:0.2; roughness:0.5"
                press-button
                shadow="cast: true; receive: true"
                static-body="shape: box">
          </a-box>

          <!-- √©tiquette -->
          <a-entity text="value: RESET; align: center; color: #fff; width: 1.2"
                    position="0 0.67 0"></a-entity>
        </a-entity>

        <!-- Score -->
        <a-entity id="score-board" position="2 1 -2" rotation="0 -30 0">
          <a-plane width="0.7" height="0.6" color="#222" opacity="0.8"></a-plane>
          <a-entity id="score-text" text="value: Score: 0; align: center; color: #0f0; width: 1.8"
                    position="0 0 0.01"></a-entity>
        </a-entity>
        <!-- Tableau de score style bowling (au-dessus du panneau actuel) -->
        <a-entity id="score-table"
                  position="2 1.55 -2" rotation="0 -30 0"
                  bowling-scoreboard="cols:10; cellW:0.18; cellH:0.10; gap:0.006">
        </a-entity>


        <a-entity id="ball-and-boxes" position="0 0 0.4">
          <!-- Box contenant balle facile-->
          <a-entity id="ball-box" position="-0.1 0 0.24">
            <!-- sol de la box -->
            <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                  material="color:#666; metalness:0.3; roughness:0.8"
                  static-body="shape: box"></a-box>
            <!-- murs de la box -->
            <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
              <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
              <a-entity text="value: Balle facile; align: center; color: #0f0; width: 1.4"
                        position="0 0 0.01"></a-entity>
            </a-entity>
          </a-entity>

          <!-- Box contenant balle moyenne-->
          <a-entity id="ball-box" position="-0.1 0 0.75">
            <!-- sol de la box -->
              <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                    material="color:#666; metalness:0.3; roughness:0.8"
                    static-body="shape: box"></a-box>
              <!-- murs de la box -->
              <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
                <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
                <a-entity text="value: Balle normal; align: center; color: #0f0; width: 1.4"
                          position="0 0 0.01"></a-entity>
              </a-entity>
            </a-entity>

            <!-- Box contenant balle difficile-->
            <a-entity id="ball-box" position="-0.1 0 1.26">
              <!-- sol de la box -->
              <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                    material="color:#666; metalness:0.3; roughness:0.8"
                    static-body="shape: box"></a-box>
              <!-- murs de la box -->
              <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
                <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
                <a-entity text="value: Balle impossible; align: center; color: #0f0; width: 1.4"
                          position="0 0 0.01"></a-entity>
              </a-entity>
            </a-entity>

            <!-- Disclaimer de prendre qu'une seule balle √† la fois -->
            <a-entity position="-0.413 0.976 0.983" rotation="0 90 0">
              <a-plane width="1.4" height="0.2" color="#222" opacity="0.8"></a-plane>
              <a-entity text="value: Prenez une seule balle √† la fois!; align: center; color: #f00; width: 2"
                        position="0 0 0.01"></a-entity>
            </a-entity>
          <!-- OBJETS SAISISSABLES (physiques) -->
          <!-- Boules de bowling -->

          <!-- facile -->
          <a-sphere id="ball-easy" class="bowling-ball grabbable" resettable position="-0.081 0.170 0.408" radius="0.15" color="#EF2D5E"
                    shadow="cast: true; receive: true" opacity="0"
                    grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                    dynamic-body="mass: 10; shape: sphere"
                    sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                    sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                    sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                    <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.19 0.19 0.19"></a-entity>
          </a-sphere>

            <!-- moyen -->
          <a-sphere id="ball-medium" class="bowling-ball grabbable" resettable position="-0.081 0.170 0.918" radius="0.1" color="#EF2D5E"
                    shadow="cast: true; receive: true" opacity="0"
                    grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                    dynamic-body="mass: 1; shape: sphere"
                    sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                    sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                    sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                    <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.126 0.126 0.126"></a-entity>
          </a-sphere>

            <!-- difficile -->
          <a-sphere id="ball-hard" class="bowling-ball grabbable" resettable position="-0.081 0.170 1.428" radius="0.05" color="#EF2D5E"
                    shadow="cast: true; receive: true" opacity="0"
                    grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                    dynamic-body="mass: 0.1; shape: sphere"
                    sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                    sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                    sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                    <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.063 0.063 0.063"></a-entity>
          </a-sphere>
        </a-entity>

        <!-- Quilles align√©es fa√ßon bowling (1‚Äì2‚Äì3‚Äì4) -->
        <!-- Quilles bowling resserr√©es (√©cart entre lignes r√©duit) -->
        <a-entity id="pins" rotation="0 0 0" position="0.008 0.1 -2.5">
          <a-cylinder class="grabbable" resettable position="1.0 0.1 -1.9" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.9 0.1 -2.1" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.1 0.1 -2.1" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.8 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.0 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.2 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.7 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="0.9 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.1 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.3 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
        </a-entity>

        <!-- murs invisibles -->
        <a-box position="1 1.5  2" width="4" height="3" depth="0.1"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <a-box position="1 1.5 -7" width="4" height="3" depth="0.1"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <a-box position="-1 1.5 -2" width="0.1" height="3" depth="10"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <a-box position="3 1.5 -2" width="0.1" height="3" depth="10"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <!-- R√®gle au dessus du mur du fond-->
        <a-entity id="game-rules" position="0 2 -5.6">
          <a-plane width="2.5" height="1.5" color="#222" opacity="0.8" position="1 0 0"></a-plane>
          <a-entity text="value: Regle du jeu:
                                - Prenez une seule balle a la fois.
                                - Lancez-la en la lachant ou en la projetant.
                                - Apres chaque lancer, attendez que la balle soit revenue et que les quilles soient immobiles.
                                - Appuyez sur le bouton RESET pour recommencer une partie.
                                \nCe jeu a ete realise dans le cadre du projet WebVR par Fabio MALTA, Nicolas POROT, Mateo BIAUT et Benjamin JOANNARD; align: center; color: #fff; width: 2.2"
                    position="1 0 0.01"></a-entity>
        </a-entity>


        <a-entity id="announcer"
          sound__strike="src: #sfx-strike; volume: 0.9; positional: false"
          sound__spare="src: #sfx-spare;  volume: 0.8; positional: false">
        </a-entity>

        <a-entity id="bgm"
          bgm-controller
          sound__bgm="src: #sfx-music; loop: true; positional: false; autoplay: false; volume: 0.25">
        </a-entity>

        <a-entity id="tung" gltf-model="#tung" position="-0.3 0 -0.3" scale="0.1 0.1 0.1" rotation="0 45 0">
          <!-- text tung tung sahur-->
          <a-entity text="value: Salut l'ami !\n Choisi ta boule et lance la sur les quilles !; align: center; color: #FFF; width: 15"
                    position="0 16 0"></a-entity>
        </a-entity>
        
       <!-- SOL : √† y = 0 (garde shape: plane) -->
        <a-plane position="0 -0.1 -1" rotation="-90 0 0" width="100" height="100" opacity="0"
                shadow="cast: false; receive: true"
                static-body="shape: plane"
                material="shader: flat; src: #groundTexture; repeat: 100 100"></a-plane>

        <a-sky src="#skyTexture"></a-sky>
      </a-scene>
    </body>
</html>