<!DOCTYPE html>
<html>
    <head>
      <meta charset="utf-8" />
      <title>Projet WebVR</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />

      <!-- A-Frame 1.7.0 -->
      <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

      <!-- A-Frame 1.5+ : éviter le conflit de nom "grabbable" -->
      <script> delete AFRAME.components["grabbable"]; </script> <!-- cf. super-hands -->

      <!-- aframe-extras (sphere-collider) -->
      <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

      <!-- Physics system (CANNON/Ammo support) -->
      <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

      <!-- super-hands 3.x -->
      <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

      <!-- Tes composants de déplacement -->
      <script>
        // Déplacement joystick gauche
        AFRAME.registerComponent('joystick-movement', {
        schema: {
          speed: {type: 'number', default: 2},
          minX: {type: 'number', default: -0.78}, // murs à x=-1 et x=3, ray. joueur ≈ 0.22
          maxX: {type: 'number', default:  2.78},
          minZ: {type: 'number', default: -6.78}, // murs à z=-7 et z=2
          maxZ: {type: 'number', default:  1.78}
        },
        init: function () {
          const rig = document.querySelector('#rig');
          const head = document.querySelector('#head');
          const leftHand = document.querySelector('#leftHand');
          const DEADZONE = 0.1;
          const speed = this.data.speed;
          const clamp = (v, a, b) => Math.min(Math.max(v, a), b);

          leftHand.addEventListener('thumbstickmoved', (evt) => {
            const dx = evt.detail.x, dy = evt.detail.y;
            if (Math.abs(dx) < DEADZONE && Math.abs(dy) < DEADZONE) return;

            // axes locaux (avant/droite) à plat
            const forward = new THREE.Vector3();
            head.object3D.getWorldDirection(forward);
            forward.y = 0; forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

            // petit pas (évite le "tunneling")
            const step = 0.04 * speed;

            // On applique séparément X puis Z -> "glisse" sur les murs
            const p = rig.object3D.position.clone();

            // tentative X
            const nx = p.x + (right.x * dx + forward.x * dy) * step;
            const clampedX = clamp(nx, this.data.minX, this.data.maxX);
            p.x = clampedX;

            // tentative Z
            const nz = rig.object3D.position.z + (right.z * dx + forward.z * dy) * step;
            const clampedZ = clamp(nz, this.data.minZ, this.data.maxZ);
            p.z = clampedZ;

            rig.object3D.position.copy(p);
          });
        }
      });


        // Rotation par crans (joystick droit)
        AFRAME.registerComponent('snap-turn', {
          schema: { angle: { type: 'number', default: 30 }, cooldown: { type: 'number', default: 300 } },
          init: function () {
            const rig = document.querySelector('#rig');
            const rightHand = document.querySelector('#rightHand');
            const angle = this.data.angle, cooldown = this.data.cooldown;
            let lastTurn = 0;
            rightHand.addEventListener('thumbstickmoved', function (evt) {
              const now = Date.now(), x = evt.detail.x;
              if (Math.abs(x) < 0.8 || now - lastTurn < cooldown) return;
              const rad = THREE.MathUtils.degToRad(angle);
              if (x > 0.8)  rig.object3D.rotation.y -= rad;
              else          rig.object3D.rotation.y += rad;
              lastTurn = now;
            });
          }
        });
      /** Marque les entités à réinitialiser et mémorise leur état initial */
      
      AFRAME.registerComponent('resettable', {
        init () {
          const el = this.el;
          // Mémorise local + MONDE (pour éviter les surprises avec les parents décalés)
          this.startLocalPos = el.object3D.position.clone();
          this.startLocalRot = el.object3D.rotation.clone();

          this.startWorldPos = new THREE.Vector3();
          this.startWorldQuat = new THREE.Quaternion();
          el.object3D.getWorldPosition(this.startWorldPos);
          el.object3D.getWorldQuaternion(this.startWorldQuat);
        },

        resetNow () {
          const el = this.el;
          const eps = 0.005; // petit lift pour éviter l’interpénétration

          // 1) Remettre la partie visuelle (local)
          el.object3D.position.copy(this.startLocalPos);
          el.object3D.rotation.copy(this.startLocalRot);
          el.object3D.updateMatrixWorld(true);

          // 2) Si le body physique existe, le remettre en MONDE (sinon on attend 'body-loaded')
          const applyToBody = (body) => {
            if (!body) return;
            // Position monde + petit epsilon Y
            const p = this.startWorldPos.clone(); p.y += eps;

            // ----- Cannon.js -----
            if (body.position && body.quaternion) {
              body.position.set(p.x, p.y, p.z);
              body.quaternion.set(this.startWorldQuat.x, this.startWorldQuat.y, this.startWorldQuat.z, this.startWorldQuat.w);
              if (body.velocity) body.velocity.set(0,0,0);
              if (body.angularVelocity) body.angularVelocity.set(0,0,0);
              if (body.sleep) body.sleep();
              if (body.wakeUp) body.wakeUp();
            }

            // ----- Ammo.js (aframe-physics-system l’unifie assez bien, les lignes ci-dessus suffisent souvent) -----
            try { body.activate && body.activate(); } catch(e) {}
          };

          if (el.body) {
            applyToBody(el.body);
            // Sync A-Frame -> Physique si dispo
            try { el.components['dynamic-body']?.syncToPhysics(); } catch(e) {}
          } else {
            // Le body n'est pas encore créé (rare ici) : attendre et appliquer
            el.addEventListener('body-loaded', () => applyToBody(el.body), {once:true});
          }
        }
      });

      AFRAME.registerComponent('press-button', {
        schema: { cooldown: {type: 'number', default: 400} },
        init() {
          const el = this.el;
          const base = el.object3D.position.clone();
          this.upY   = base.y;
          this.downY = this.upY - 0.02;
          this.last  = 0;

          el.setAttribute('animation__down',
            `property: position; to: ${base.x} ${this.downY} ${base.z}; dur: 70; easing: easeOutQuad; startEvents: goDown; dir: normal`);
          el.setAttribute('animation__up',
            `property: position; to: ${base.x} ${this.upY} ${base.z}; dur: 120; easing: easeOutQuad; startEvents: goUp; dir: normal`);

          const doHardReset = () => {
            const now = Date.now();
            if (now - this.last < this.data.cooldown) return;
            this.last = now;

            // 1) reset TOUT ce qui est resettable (balle + quilles…)
            document.querySelectorAll('[resettable]').forEach(e => e.components.resettable?.resetNow());
            // 2) prévenir le scorekeeper qu'on veut un "vrai" reset d'état (frame=1, roll=1…)
            this.el.sceneEl.emit('hard-reset');
          };

          el.addEventListener('hover-start', () => { el.emit('goDown'); doHardReset(); });
          el.addEventListener('hover-end',   () => { el.emit('goUp'); });
          el.addEventListener('click',       () => { el.emit('goDown'); doHardReset(); setTimeout(() => el.emit('goUp'), 120); });
        }
      });


      AFRAME.registerComponent('score-keeper', {
        schema: {
          balls:   {type: 'selectorAll', default: '.bowling-ball'},
          pins:    {type: 'selector',    default: '#pins'},
          board:   {type: 'selector',    default: '#score-text'},
          settleMs:{type: 'int',    default: 2500},   // délai après contact quille
          graceMs: {type: 'int',    default: 3800},   // délai si pas de contact
          tiltDeg: {type: 'number', default: 25},
          speedThresh: {type: 'number', default: 0.05},
          maxFrames:   {type: 'int',    default: 10},
          ballReturnMs:{type: 'int',    default: 1800},
          nextFrameMs: {type: 'int',    default: 2000},
          throwSpeedMin: {type: 'number', default: 0.8},
          throwDirZMin:  {type: 'number', default: -0.2},
          throwWindowMs: {type: 'int',    default: 1500},
          foulLineZ:     {type: 'number', default: -1.2}
        },

        init() {
          this.frame = 1; this.roll = 1;
          this.fallenSet = new Set();
          this.frameComplete = false;

          this.timer = null;
          this.ballTimer = null;
          this.nextFrameTimer = null;
          this.awaitingSettle = false;

          this.candidateThrow = null; // {ball, t0}
          this.currentBall = null;
          this.isRolling = false;
          this.hitAccum = 0;
          this.hitTimer = null;

          this.settleDueAt = 0;              // échéance (timestamp) au plus tôt pour évaluer
          this.phase = 'ready';              // 'ready' | 'rolling' | 'between'

          // --- pins / balls résolus après chargement ---
          this.pinEls = [];
          this.ballEls = [];
          const wireBall = (b) => {
            if (!b || b.__wiredScoreKeeper) return;
            b.__wiredScoreKeeper = true;
            b.addEventListener('collide', this.onBallCollide);
            b.addEventListener('grab-start', this.onGrabStart);
            b.addEventListener('grab-end',   this.onGrabEnd);
          };
          const resolvePins = () => {
            const root = this.data.pins || document.querySelector('#pins');
            this.pinEls = root ? Array.from(root.querySelectorAll('a-cylinder')) : [];
            this.pinEls.forEach((p,i)=>{ if(!p.dataset.idx) p.dataset.idx=String(i+1);});
            this.pinFilterDefaults = this.pinFilterDefaults || new WeakMap();
            this.pinEls.forEach(p=>{
              if (this.pinFilterDefaults.has(p)) return;
              const stash=()=>{const b=p.body; if(!b) return;
                this.pinFilterDefaults.set(p,{group:b.collisionFilterGroup,mask:b.collisionFilterMask});};
              p.body?stash():p.addEventListener('body-loaded', stash, {once:true});
            });
          };
          const resolveBalls = () => {
            const fromAttr = this.data.balls && this.data.balls.length ? Array.from(this.data.balls) : [];
            this.ballEls = fromAttr.length ? fromAttr : Array.from(document.querySelectorAll('.bowling-ball'));
            this.ballEls.forEach(wireBall);
          };
          const resolveAndWire = () => { resolvePins(); resolveBalls(); };
          setTimeout(resolveAndWire, 0);
          this.el.addEventListener('loaded', resolveAndWire);
          this.el.sceneEl?.addEventListener('loaded', resolveAndWire);

          // --- helpers ---
          this.getSpeed = (el) => {
            const v = el?.body?.velocity; if (!v) return 0;
            return Math.hypot(v.x, v.y, v.z);
          };
          this.updateRollingSound = () => {
            const b = this.currentBall; if (!b) return;
            const speed = this.getSpeed(b);
            const onLane = (b.object3D.position.y < 0.30);
            const wantPlay = onLane && speed > 0.25;
            const roll = b.components['sound__roll']; if (!roll) return;
            if (wantPlay && !this.isRolling) { roll.playSound(); this.isRolling = true; }
            if (!wantPlay && this.isRolling) { roll.stopSound(); this.isRolling = false; }
          };
          this.queuePinHit = (powerNorm) => {
            this.hitAccum = Math.max(this.hitAccum, powerNorm);
            if (this.hitTimer) return;
            this.hitTimer = setTimeout(()=>{
              const b=this.currentBall;
              if (b) {
                const vol = THREE.MathUtils.clamp(0.25 + 0.75*this.hitAccum, 0, 1);
                b.setAttribute('sound__pins','volume',vol);
                b.components['sound__pins']?.playSound();
              }
              this.hitAccum=0; this.hitTimer=null;
            },80);
          };

          // ★ helpers de phase : balle revenue à la zone de départ ?
          this.isBallHome = (b) => {
            if (!b?.object3D) return false;
            const p = b.object3D.position;
            const v = b?.body?.velocity || {x:0,y:0,z:0};
            const speed = Math.hypot(v.x, v.y, v.z);
            const inStartZone = p.z > -0.6 && p.y < 0.4; // ajuste si nécessaire
            return inStartZone && speed < this.data.speedThresh;
          };

          this.rearmWhenReady = () => {
            const anyHome = this.ballEls.some(b => this.isBallHome(b));
            if (anyHome && !this.frameComplete) {
              this.phase = 'ready';
            } else {
              setTimeout(() => { if (this.phase === 'between') this.rearmWhenReady(); }, 150);
            }
          };

          // --- handlers ball ---
          this.onBallCollide = (e) => {
            if (this.phase === 'between') return; // ignorer pendant le retour/entre-lancers
            const ballEl=e.target, other=e.detail?.body?.el; if (!other) return;
            if (this.pinEls.includes(other)) {
              this.currentBall = ballEl;
              const v = this.getSpeed(ballEl);
              const powerNorm = THREE.MathUtils.clamp(v/4.0,0,1);
              if (powerNorm>0.1) this.queuePinHit(powerNorm);
              // contact quille => possible délai court
              this.armSettleTimer(this.data.settleMs);
            }
          };
          this.onGrabStart = (e)=>{ this.currentBall = e.target; };
          this.onGrabEnd = (e)=>{
            const b = e.target;
            setTimeout(()=>{
              if (this.phase !== 'ready') return; // pas de nouveau lancer hors phase ready
              const v=b?.body?.velocity, speed=this.getSpeed(b);
              if (speed>0.4) b.components['sound__throw']?.playSound();
              const okSpeed = speed >= this.data.throwSpeedMin;
              const okDir   = v && (v.z <= this.data.throwDirZMin);
              const okAlt   = b.object3D.position.y < 0.5;
              if (okSpeed && okDir && okAlt) this.candidateThrow = {ball:b, t0:performance.now()};
            },20);
          };

          // --- tick : garde-fous ligne de faute + délais ---
          this.tick = () => {
            this.updateRollingSound();

            // (A) Candidature -> franchit la ligne
            if (this.phase === 'ready' && this.candidateThrow) {
              const {ball,t0}=this.candidateThrow;
              const now=performance.now();
              const pos=ball.object3D.position;
              const speed=this.getSpeed(ball);
              const expired=(now-t0)>this.data.throwWindowMs;
              const slowed = speed<0.25;
              if ((expired||slowed) && pos.z>this.data.foulLineZ) this.candidateThrow=null;
              if (pos.z<=this.data.foulLineZ) {
                this.currentBall=ball;
                this.candidateThrow=null;
                // franchit la ligne sans contact (pour l’instant) : délai long
                this.armSettleTimer(this.data.graceMs);
              }
            }

            // (B) Fallback : n’importe quelle balle franchit la ligne (en avançant)
            if (this.phase === 'ready' && !this.awaitingSettle && !this.frameComplete) {
              for (const b of this.ballEls) {
                if (!b?.object3D) continue;
                const v = b?.body?.velocity;
                const goingForward = v && (v.z <= this.data.throwDirZMin);
                if (goingForward && b.object3D.position.z <= this.data.foulLineZ) {
                  this.currentBall = b;
                  this.armSettleTimer(this.data.graceMs);
                  break;
                }
              }
            }

            // (C) Immobile -> possible évaluation, mais seulement après l’échéance
            if (this.awaitingSettle && this.currentBall?.body) {
              const now = performance.now();
              if (now >= this.settleDueAt && this.getSpeed(this.currentBall) < this.data.speedThresh) {
                this.evaluateNow();
              }
            }
          };

          // reset global
          this.onHardReset = () => { this.fullResetState(); };
          this.el.sceneEl.addEventListener('hard-reset', this.onHardReset);

          this.updateBoard({thisRoll:0, totalDown:0, tag:''});
        },

        remove() {
          this.ballEls.forEach(b=>{
            b.removeEventListener('collide',this.onBallCollide);
            b.removeEventListener('grab-start',this.onGrabStart);
            b.removeEventListener('grab-end',this.onGrabEnd);
            b.__wiredScoreKeeper=false;
          });
          this.el.sceneEl.removeEventListener('hard-reset', this.onHardReset);
          this.clearTimer(); this.clearBallTimer(); this.clearNextFrameTimer();
          this.candidateThrow=null;
        },

        // --- timers / outils d'état ---
        // accepte une durée et mémorise l’échéance + bascule phase
        armSettleTimer(ms) {
          if (this.frameComplete) return;
          if (this.phase !== 'ready' && this.phase !== 'rolling') {
            // si on est "between", on n'arme pas
            return;
          }
          // si on est encore "ready", on passe en "rolling"
          if (this.phase === 'ready') this.phase = 'rolling';

          this.clearTimer();
          const dur = (ms ?? this.data.settleMs);
          this.awaitingSettle = true;
          this.settleDueAt = performance.now() + dur;
          this.timer = setTimeout(()=>this.evaluateNow(), dur);
        },
        clearTimer(){ if(this.timer) clearTimeout(this.timer); this.timer=null; },
        clearBallTimer(){ if(this.ballTimer) clearTimeout(this.ballTimer); this.ballTimer=null; },
        clearNextFrameTimer(){ if(this.nextFrameTimer) clearTimeout(this.nextFrameTimer); this.nextFrameTimer=null; },

        isUpright(pinEl){
          const q=new THREE.Quaternion();
          pinEl.object3D.getWorldQuaternion(q);
          const up=new THREE.Vector3(0,1,0).applyQuaternion(q);
          const angle=up.angleTo(new THREE.Vector3(0,1,0));
          return THREE.MathUtils.radToDeg(angle) < this.data.tiltDeg;
        },
        getDownPins(){ return this.pinEls.filter(p=>!this.isUpright(p)); },

        moveEntityToWorld(el, worldPos, quat=null){
          const parent=el.object3D.parent;
          const local=worldPos.clone(); if(parent) parent.worldToLocal(local);
          el.object3D.position.copy(local);
          if (quat) el.object3D.quaternion.copy(quat);
          el.object3D.updateMatrixWorld(true);
          const body=el.body;
          if(body){
            const p=worldPos.clone(); p.y+=0.002;
            body.position?.set(p.x,p.y,p.z);
            if (quat && body.quaternion) body.quaternion.set(quat.x,quat.y,quat.z,quat.w);
            body.velocity?.set(0,0,0);
            body.angularVelocity?.set(0,0,0);
            try{ el.components['dynamic-body']?.syncToPhysics(); }catch(e){}
          }
        },

        ghostifyPin(pinEl){ const b=pinEl.body; if(!b) return; b.collisionResponse=false; b.collisionFilterMask=0; b.velocity?.set(0,0,0); b.angularVelocity?.set(0,0,0); },
        restorePin(pinEl){
          const b=pinEl.body; if(!b) return;
          const def=this.pinFilterDefaults?.get(pinEl);
          if(def){ b.collisionFilterGroup=def.group; b.collisionFilterMask=def.mask; }
          else { b.collisionFilterGroup=1; b.collisionFilterMask=-1; }
          b.collisionResponse=true;
        },
        restoreAllPins(){ this.pinEls.forEach(p=>this.restorePin(p)); },

        parkFallenPins(){
          const base=new THREE.Vector3(1.0,0.05,-6.2), dx=0.16, dz=0.34;
          let i=0; const fallen=Array.from(this.fallenSet);
          fallen.forEach(pinEl=>{
            if (this.isUpright(pinEl)) return;
            const col=i%5, row=(i/5)|0;
            const target=base.clone(); target.x+=(col-2)*dx; target.z-=row*dz;
            this.moveEntityToWorld(pinEl,target,null); i++; this.ghostifyPin(pinEl);
          });
        },

        evaluateNow(){
          if (this.frameComplete) return;
          this.phase = 'between';                 // on gèle tout nouveau lancer
          this.clearTimer(); this.awaitingSettle=false; this.settleDueAt = 0;

          const downNow=this.getDownPins();
          const downSetNow=new Set(downNow);
          const thisRollKnocked = downNow.filter(p=>!this.fallenSet.has(p)).length;
          const totalDown = new Set([...this.fallenSet, ...downSetNow]).size;

          let tag=''; 
          if(this.roll===1 && totalDown===10) tag='STRIKE!'; 
          if(this.roll===2 && totalDown===10) tag='SPARE!';
          if(totalDown===0) tag='Gutter!';
          this.updateBoard({thisRoll:thisRollKnocked, totalDown, tag});
          const announcer=document.querySelector('#announcer');
          if(tag==='STRIKE!') announcer?.components['sound__strike']?.playSound();
          if(tag==='SPARE!')  announcer?.components['sound__spare']?.playSound();
          if(tag==='Gutter!')  announcer?.components['sound__gutter']?.playSound();

          downSetNow.forEach(p=>this.fallenSet.add(p));
          this.el.sceneEl.emit('score:roll',{ pins:thisRollKnocked, frame:this.frame, roll:this.roll });

          if (this.roll===1){
            if (totalDown===10){
              this.frameComplete=true; this.clearBallTimer(); this.scheduleNextFrame();
            } else {
              this.roll=2; this.scheduleBallReturn(); this.parkFallenPins();
            }
          } else {
            this.frameComplete=true; this.clearBallTimer(); this.scheduleNextFrame();
          }
        },

        scheduleBallReturn(){
          this.clearBallTimer();
          this.ballTimer=setTimeout(()=>{
            if(this.frameComplete || this.roll!==2) return;
            const toReset=this.currentBall || this.ballEls[0];
            toReset?.components.resettable?.resetNow();
            this.isRolling=false; this.currentBall?.components['sound__roll']?.stopSound();
            this.phase = 'between';
            setTimeout(() => this.rearmWhenReady(), 120);
          }, this.data.ballReturnMs);
        },

        scheduleNextFrame(){
          this.clearNextFrameTimer();
          this.nextFrameTimer=setTimeout(()=>{
            this.isRolling=false; this.currentBall?.components['sound__roll']?.stopSound();
            this.phase = 'between';
            this.restoreAllPins();
            [...document.querySelectorAll('[resettable]')].forEach(e=>e.components.resettable?.resetNow());
            this.settleDueAt = 0;
            this.advanceFrame();
            setTimeout(() => { if (!this.frameComplete) this.phase = 'ready'; }, 120);
          }, this.data.nextFrameMs);
        },

        updateBoard({thisRoll, totalDown, tag}){
          const left=`Tour: ${this.frame}  Lancer: ${this.roll}`;
          const right=`+${thisRoll} (total ${totalDown}/10)`;
          const extra=tag?`  ${tag}`:'';
          this.data.board.setAttribute('text','value',`${left} —\n ${right}\n${extra}`);
        },

        advanceFrame(){
          this.fallenSet.clear(); this.frameComplete=false; this.roll=1; this.frame+=1;
          if (this.frame > this.data.maxFrames) {
            this.frame = 1;
            // ➜ prévenir le tableau de repartir de zéro
            this.el.sceneEl.emit('score:reset');
          }
          this.updateBoard({thisRoll:0, totalDown:0, tag:''});
        },

        fullResetState(){
          this.clearTimer(); this.clearBallTimer(); this.clearNextFrameTimer();
          this.awaitingSettle=false; this.settleDueAt = 0;
          this.fallenSet.clear(); this.frameComplete=false;
          this.frame=1; this.roll=1; this.restoreAllPins();
          this.updateBoard({thisRoll:0, totalDown:0, tag:''});
          this.isRolling=false; this.currentBall?.components['sound__roll']?.stopSound();
          this.candidateThrow=null;
          this.phase = 'ready';
        }
      });



      // Lance la musique après le premier geste utilisateur (click / enter-vr)
      AFRAME.registerComponent('bgm-controller', {
        init() {
          const el = this.el; // l'entité qui porte sound__bgm
          const start = () => {
            // évite double start
            if (this.started) return;
            this.started = true;
            el.components['sound__bgm']?.playSound();
            window.removeEventListener('click', start);
            el.sceneEl.removeEventListener('enter-vr', start);
          };
          // un clic n'importe où ou l’entrée en VR suffisent
          window.addEventListener('click', start, { once: true });
          el.sceneEl.addEventListener('enter-vr', start, { once: true });
        }
      });

      /**
       * bowling-scoreboard
       * - Génère une grille 10 frames.
       * - Écoute les events :
       *   - 'score:roll'  => { pins, frame, roll }  (émis par score-keeper après chaque lancer)
       *   - 'hard-reset'  => réinitialise tout
       * - Calcule les scores cumulés en appliquant les règles bowling (strike/spare).
       */
      AFRAME.registerComponent('bowling-scoreboard', {
        schema: {
          cols:  {type: 'int', default: 10},
          cellW: {type: 'number', default: 0.18},
          cellH: {type: 'number', default: 0.10},
          gap:   {type: 'number', default: 0.006}
        },

        init() {
          this.rolls = [];            // tableau de valeurs par lancer (0..10)
          this.framesView = [];       // [{r1:'', r2:'', r3:''?, cum:''}, ...]
          this.cells = [];            // références UI par frame : {r1,r2,r3,cum,box}

          this.buildGrid();

          // écoute les événements
          this.onRoll = (e) => {
            const pins = Math.max(0, Math.min(10, (e.detail?.pins ?? 0)));
            this.rolls.push(pins);
            this.refresh();
          };
          this.onHardReset = () => { this.resetAll(); };
          this.onScoreReset = () => { this.resetAll(); };

          this.el.sceneEl.addEventListener('score:roll',  this.onRoll);
          this.el.sceneEl.addEventListener('hard-reset',  this.onHardReset);
          this.el.sceneEl.addEventListener('score:reset', this.onScoreReset);

          // init
          this.resetAll();
        },

        remove() {
          this.el.sceneEl.removeEventListener('score:roll',  this.onRoll);
          this.el.sceneEl.removeEventListener('hard-reset',  this.onHardReset);
          this.el.sceneEl.removeEventListener('score:reset', this.onScoreReset);
        },

        resetAll() {
          this.rolls = [];
          this.framesView = Array.from({length: this.data.cols}, _ => ({r1:'', r2:'', r3:'', cum:''}));
          this.render();
        },

        buildGrid() {
          const {cols, cellW, cellH, gap} = this.data;
          const totalW = cols * cellW + (cols - 1) * gap;
          const totalH = cellH * 2 + gap; // ligne lancers (haut) + ligne cumul (bas)

          // fond
          const bg = document.createElement('a-plane');
          bg.setAttribute('width',  totalW + 0.04);
          bg.setAttribute('height', totalH + 0.04);
          bg.setAttribute('color', '#111');
          bg.setAttribute('opacity', 0.85);
          this.el.appendChild(bg);

          this.cells = [];

          // créer 10 colonnes (frames)
          const startX = -totalW / 2 + cellW/2;
          const topY   =  totalH / 2 - cellH/2;

          for (let i = 0; i < cols; i++) {
            const colX = startX + i * (cellW + gap);

            // cadre de la frame
            const box = document.createElement('a-plane');
            box.setAttribute('position', `${colX} 0 0.001`);
            box.setAttribute('width',  cellW);
            box.setAttribute('height', totalH);
            box.setAttribute('color', '#222');
            box.setAttribute('opacity', 0.95);
            this.el.appendChild(box);

            // séparateur horizontal (entre lancers et cumul)
            const sep = document.createElement('a-plane');
            sep.setAttribute('position', `${colX} ${topY - (cellH + gap/2)} 0.002`);
            sep.setAttribute('width', cellW);
            sep.setAttribute('height', 0.003);
            sep.setAttribute('color', '#555');
            this.el.appendChild(sep);

            // en-tête numéro de frame
            const head = document.createElement('a-entity');
            head.setAttribute('position', `${colX} ${topY + 0.07} 0.003`);
            head.setAttribute('text', {
              value: String(i+1),
              align: 'center',
              color: '#9ad',
              width: 1.4
            });
            this.el.appendChild(head);

            // cases texte : r1 r2 (et r3 pour la 10e), cum
            const r1 = document.createElement('a-entity');
            r1.setAttribute('position', `${colX - cellW*0.22} ${topY} 0.003`);
            r1.setAttribute('text', {value:'', align:'center', color:'#fff', width:1.8});
            const r2 = document.createElement('a-entity');
            r2.setAttribute('position', `${colX + cellW*0.10} ${topY} 0.003`);
            r2.setAttribute('text', {value:'', align:'center', color:'#fff', width:1.8});
            const r3 = document.createElement('a-entity');
            r3.setAttribute('position', `${colX + cellW*0.35} ${topY} 0.003`);
            r3.setAttribute('text', {value:'', align:'center', color:'#fff', width:1.8, opacity: (i===9)?1:0}); // visible 10e frame

            const cum = document.createElement('a-entity');
            cum.setAttribute('position', `${colX} ${-totalH/2 + cellH/2} 0.003`);
            cum.setAttribute('text', {value:'', align:'center', color:'#0f0', width:1.6});

            this.el.appendChild(r1);
            this.el.appendChild(r2);
            this.el.appendChild(r3);
            this.el.appendChild(cum);

            this.cells.push({box, r1, r2, r3, cum});
          }
        },

        // Convertit une valeur de lancer -> symbole bowling ('X', '/', '-', chiffre)
        symbolFor(rollVal, prevRollVal=null, isTenth=false, isFirst=false) {
          if (rollVal === 10 && (isFirst || isTenth)) return 'X';
          if (rollVal === 0) return '-';
          if (prevRollVal != null && prevRollVal + rollVal === 10 && !isFirst) return '/';
          return String(rollVal);
        },

        // Calcule toutes les frames + cumul à partir de this.rolls
        computeFrames() {
          const frames = [];
          let i = 0;

          for (let f = 1; f <= 10; f++) {
            if (f < 10) {
              const r1 = this.rolls[i] ?? null;
              const strike = (r1 === 10);

              if (r1 == null) {
                // Frame pas commencée
                frames.push({ r1:null, r2:null, r3:null, score:null, kind:'open' });
                break;
              }

              if (strike) {
                const b1 = this.rolls[i+1];
                const b2 = this.rolls[i+2];
                const ready = (b1 != null) && (b2 != null);
                frames.push({
                  r1: 10, r2: null, r3: null,
                  score: ready ? 10 + b1 + b2 : null,
                  kind: 'X'
                });
                i += 1;
              } else {
                const r2 = this.rolls[i+1] ?? null;

                if (r2 == null) {
                  // Frame en cours (1er lancer connu, 2e pas encore)
                  frames.push({ r1, r2:null, r3:null, score:null, kind:'open' });
                  break;
                }

                const sum = r1 + r2;
                if (sum === 10) {
                  // Spare -> bonus d’un lancer nécessaire
                  const b = this.rolls[i+2];
                  const ready = (b != null);
                  frames.push({
                    r1, r2, r3:null,
                    score: ready ? 10 + b : null,
                    kind: '/'
                  });
                } else {
                  // Ouverte -> score immédiat
                  frames.push({ r1, r2, r3:null, score: sum, kind:'open' });
                }
                i += 2;
              }
            } else {
              // 10e frame : jusqu'à 3 lancers si strike/spare
              const r1 = this.rolls[i]   ?? null;
              const r2 = this.rolls[i+1] ?? null;
              let r3 = null;
              let score = null;

              if (r1 != null && r2 != null) {
                const needsR3 = (r1 === 10) || (r1 + r2 === 10);
                if (needsR3) {
                  r3 = this.rolls[i+2] ?? null;
                  if (r3 != null) score = r1 + r2 + r3; // complet
                } else {
                  score = r1 + r2; // frame complète sans bonus
                }
              }
              frames.push({ r1, r2, r3, score, kind:'tenth' });
              // pas d'incrément de i : fin du parcours
            }
          }

          // cumul : seulement quand la frame est vraiment scorée
          let running = 0;
          for (let k = 0; k < frames.length; k++) {
            if (frames[k].score != null) {
              running += frames[k].score;
              frames[k].cum = running;
            } else {
              frames[k].cum = null;
            }
          }
          return frames;
        },


        refresh() {
          this.framesView = this.computeFrames();
          this.render();
        },

        render() {
          // efface style actif
          this.cells.forEach((c, idx) => {
            c.box.setAttribute('color', idx === this.activeFrameIndex()? '#333' : '#222');
          });

          // met à jour les 10 frames
          for (let f = 0; f < 10; f++) {
            const cell = this.cells[f];
            const data = this.framesView[f] || {r1:'', r2:'', r3:'', cum:''};

            // Lancers -> symboles
            if (f < 9) {
              const r1v = (data.r1 ?? null);
              const r2v = (data.r2 ?? null);
              const r1s = (r1v==null) ? '' : this.symbolFor(r1v, null, false, true);
              const r2s = (r2v==null) ? '' : this.symbolFor(r2v, r1v, false, false);
              cell.r1.setAttribute('text', 'value', r1s);
              cell.r2.setAttribute('text', 'value', r2s);
              cell.r3.setAttribute('text', 'value', '');
              cell.r3.setAttribute('text', 'opacity', 0);
            } else {
              // 10e frame (peut afficher 3 symboles)
              const r1v = (data.r1 ?? null);
              const r2v = (data.r2 ?? null);
              const r3v = (data.r3 ?? null);
              const r1s = (r1v==null) ? '' : this.symbolFor(r1v, null, true, true);
              const r2s = (r2v==null) ? '' : this.symbolFor(r2v, r1v, true, false);
              // Pour r3, l’indicateur de spare se fait par rapport à r2 uniquement si r1 != 10 et r1+r2 == 10,
              // sinon symbole standard (X/-/nombre).
              let r3s = '';
              if (r3v != null) {
                if (r1v !== 10 && r1v != null && r2v != null && (r1v + r2v === 10)) {
                  // bonus après spare -> r3 affiché normalement (X/-/num)
                  r3s = this.symbolFor(r3v, null, true, true);
                } else {
                  r3s = this.symbolFor(r3v, r2v, true, false);
                }
              }
              cell.r1.setAttribute('text', 'value', r1s);
              cell.r2.setAttribute('text', 'value', r2s);
              cell.r3.setAttribute('text', 'value', r3s);
              cell.r3.setAttribute('text', 'opacity', 1);
            }

            // Cumul
            const cumTxt = (data.cum == null) ? '' : String(data.cum);
            cell.cum.setAttribute('text', 'value', cumTxt);
          }
        },

        // essaie de repérer la frame en cours pour surligner
        activeFrameIndex() {
          // Compte frames complètes à partir des lancers
          let i = 0, frameIdx = 0;
          for (; frameIdx < 9 && i < this.rolls.length; frameIdx++) {
            if (this.rolls[i] === 10) i += 1; else i += 2;
            if (i > this.rolls.length) break;
          }
          return Math.min(frameIdx, 9);
        }
      });

    </script>

    </head>

    <body>
      <a-scene
        shadow="type: pcfsoft"
        renderer="antialias: true"
        vr-mode-ui="enabled: true"
        device-orientation-permission-ui="enabled: true"
        physics="gravity: -9.8; debug: false"
        score-keeper="balls: .bowling-ball; pins: #pins; board: #score-text; settleMs: 2000; tiltDeg: 25; throwSpeedMin:0.8; throwDirZMin:-0.2; throwWindowMs:1500; foulLineZ:-1.2; settleMs: 2000; graceMs: 3800">
        <!-- Assets -->
        <a-assets>

          <img id="skyTexture" src="./assets/skynet.png" />
          <img id="groundTexture" src="./assets/grass.jpg" />
          <a-asset-item id="bowlingball" src="assets/VR_Bowling_ball.glb"></a-asset-item>
          <a-asset-item id="bowlingpin" src="assets/VR_Bowling_pin.glb"></a-asset-item>
          <a-asset-item id="terrainModel" src="assets/VR_Forest.glb"></a-asset-item>
          <a-asset-item id="tung" src="assets/VR_Tung.glb"></a-asset-item>
          <audio id="sfx-throw"  src="assets/sfx/throw-whoosh.mp3"></audio>
          <audio id="sfx-roll"   src="assets/sfx/ball-roll-loop.mp3"></audio>
          <audio id="sfx-pin"    src="assets/sfx/pins-hit.mp3"></audio>
          <audio id="sfx-strike" src="assets/sfx/strike.mp3"></audio>
          <audio id="sfx-spare"  src="assets/sfx/spare.mp3"></audio>
          <audio id="sfx-gutter" src="assets/sfx/gutter.mp3"></audio>
          <audio id="sfx-music" src="assets/sfx/bgm.mp3" crossorigin="anonymous"></audio>


        </a-assets>

        <!-- Lumières -->
        <a-entity light="type: ambient; intensity: 0.4"></a-entity>
        <a-entity light="type: directional; intensity: 1; castShadow: true" position="-104.569 40.500 467.632"></a-entity>

        <!-- RIG + caméra + contrôleurs -->
        <a-entity id="rig" position="1 0.2 1" joystick-movement="speed: 2; minX: -0.78; maxX: 2.78; minZ: -6.78; maxZ: 1.78" snap-turn="angle: 30; cooldown: 300">
          <a-entity id="head" camera wasd-controls-enabled="false" look-controls></a-entity>

          <!-- Mains : super-hands limité au bouton grip (side) + collision par sphère -->
          <a-entity id="leftHand"
            oculus-touch-controls="hand: left"
            super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
            sphere-collider="objects: .grabbable, .hoverable, .pressable"
            static-body="shape: sphere; sphereRadius: 0.03">
          </a-entity>

          <a-entity id="rightHand"
            oculus-touch-controls="hand: right"
            super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
            sphere-collider="objects: .grabbable, .hoverable, .pressable"
            static-body="shape: sphere; sphereRadius: 0.03">
          </a-entity>
        </a-entity>

        <!-- Terrain -->
        <a-entity id="terrain"
                  position="-1.710 -0.100 -6.310" rotation="0 90 0" scale="1 1 1"
                  gltf-model="#terrainModel"
                  material="side: double; roughness: 1; metalness: 0"
                  static-body="shape: hull"
                  shadow="receive: true; cast: false">
        </a-entity>

        <!-- GROUPE : piste de bowling (version full <a-box>) + extension -->
        <a-entity id="bowling-lane" position="1 0 0">

          <!-- Approche (zone de départ) -->
          <a-box position="0 0.01 -0.106" width="1.066" height="0.02" depth="2"
                material="color:#c89c6c; metalness:0.2; roughness:0.7"
                shadow="cast: true; receive: true"
                static-body="shape: box"></a-box>

          <!-- Ligne de faute -->
          <a-box position="0 0.011 -1.2" width="1.066" height="0.02" depth="0.02"
                material="color:#ffffff" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Piste (segment 1) -->
          <a-box position="0 0.01 -2.1" width="1.066" height="0.02" depth="2.0"
                material="color:#b38354; metalness:0.2; roughness:0.6"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Piste (segment 2 – extension) -->
          <!-- L’extension commence juste après le segment 1 : span [-3.9 ; -3.1] -->
          <a-box position="0 0.01 -3.5" width="1.066" height="0.02" depth="0.8"
                material="color:#b38354; metalness:0.2; roughness:0.6"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Pin deck (reculé derrière l’extension) -->
          <!-- depth=0.6 => span [-4.3 ; -3.7] -->
          <a-box position="0 0.01 -4.45" width="1.066" height="0.02" depth="2"
                material="color:#a87447; metalness:0.2; roughness:0.6"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Gouttières (allongées jusqu’au fond) -->
          <!-- On couvre approximativement de -0.6 à -4.3 => centre -2.45, depth 4 -->
          <a-box position="-0.68 -0.04 -2.45" width="0.28" height="0.02" depth="6"
                material="color:#6b6b6b; roughness:0.9"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>
          <a-box position="0.68 -0.04 -2.45" width="0.28" height="0.02" depth="6"
                material="color:#6b6b6b; roughness:0.9"
                static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Bordures (rails) allongées pareil que les gouttières -->
          <a-box position="-0.82 0.12 -2.45" width="0.04" height="0.24" depth="6"
                material="color:#444" static-body="shape: box" shadow="cast: true; receive: true"></a-box>
          <a-box position="0.82 0.12 -2.45" width="0.04" height="0.24" depth="6"
                material="color:#444" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- Repères (points) -->
          <a-box position="-0.3 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0.3 0.02 -1.8" width="0.02" height="0.004" depth="0.02"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6; roughness:0.2; metalness:0"
                shadow="receive: false; cast: false"></a-box>

          <!-- Flèches (posées sur la piste) -->
          <a-box position="-0.25 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>
          <a-box position="0.25 0.02 -1.6" width="0.06" height="0.004" depth="0.03"
                material="color:#fff; emissive:#fff; emissiveIntensity:0.6"
                shadow="receive: false; cast: false"></a-box>
          
          <!-- cercle blanc pour montrer placement du joueur -->
          <a-entity id="player-indicator" position="0 0.03 0" rotation="-90 0 0">
            <a-circle radius="0.1" color="white" opacity="1"></a-circle>
          </a-entity>

          <!-- Mur de fond (reculé) -->
          <a-box position="0 0.5 -5.5" width="1.2" height="1.0" depth="0.05"
                material="color:#222" shadow="cast: true; receive: true"></a-box>
        </a-entity>

        <!-- BOUTON RESET flottant, à droite du départ -->
        <a-entity id="reset-station" position="1.55 0 -0.6">
          <!-- pied fin -->
          <a-box position="0 0.15 0" width="0.04" height="0.9" depth="0.04"
                material="color:#444" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- plateau -->
          <a-box position="0 0.61 0" width="0.20" height="0.02" depth="0.20"
                material="color:#2b2b2b" static-body="shape: box" shadow="cast: true; receive: true"></a-box>

          <!-- bouton enfonçable -->
          <a-box id="reset-button"
                class="pressable"
                hoverable
                position="0 0.63 0"
                width="0.12" height="0.03" depth="0.12"
                material="color:#e53935; emissive:#a00000; emissiveIntensity:0.4; metalness:0.2; roughness:0.5"
                press-button
                shadow="cast: true; receive: true"
                static-body="shape: box">
          </a-box>

          <!-- étiquette -->
          <a-entity text="value: RESET; align: center; color: #fff; width: 1.2"
                    position="0 0.67 0"></a-entity>
        </a-entity>

        <!-- Score -->
        <a-entity id="score-board" position="2 1 -2" rotation="0 -30 0">
          <a-plane width="0.7" height="0.6" color="#222" opacity="0.8"></a-plane>
          <a-entity id="score-text" text="value: Score: 0; align: center; color: #0f0; width: 1.8"
                    position="0 0 0.01"></a-entity>
        </a-entity>
        <!-- Tableau de score style bowling (au-dessus du panneau actuel) -->
        <a-entity id="score-table"
                  position="2 1.55 -2" rotation="0 -30 0"
                  bowling-scoreboard="cols:10; cellW:0.18; cellH:0.10; gap:0.006">
        </a-entity>


        <a-entity id="ball-and-boxes" position="0 0 0.4">
          <!-- Box contenant balle facile-->
          <a-entity id="ball-box" position="-0.1 0 0.24">
            <!-- sol de la box -->
            <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                  material="color:#666; metalness:0.3; roughness:0.8"
                  static-body="shape: box"></a-box>
            <!-- murs de la box -->
            <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                  material="color:#444"
                  static-body="shape: box"></a-box>
            <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
              <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
              <a-entity text="value: Balle facile; align: center; color: #0f0; width: 1.4"
                        position="0 0 0.01"></a-entity>
            </a-entity>
          </a-entity>

          <!-- Box contenant balle moyenne-->
          <a-entity id="ball-box" position="-0.1 0 0.75">
            <!-- sol de la box -->
              <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                    material="color:#666; metalness:0.3; roughness:0.8"
                    static-body="shape: box"></a-box>
              <!-- murs de la box -->
              <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
                <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
                <a-entity text="value: Balle normal; align: center; color: #0f0; width: 1.4"
                          position="0 0 0.01"></a-entity>
              </a-entity>
            </a-entity>

            <!-- Box contenant balle difficile-->
            <a-entity id="ball-box" position="-0.1 0 1.26">
              <!-- sol de la box -->
              <a-box position="0 0.01 0.24" width="0.4" height="0.02" depth="0.4"
                    material="color:#666; metalness:0.3; roughness:0.8"
                    static-body="shape: box"></a-box>
              <!-- murs de la box -->
              <a-box position="0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="-0.2 0.15 0.24" width="0.02" height="0.3" depth="0.4"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.04" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-box position="0 0.15 0.44" width="0.4" height="0.3" depth="0.02"
                    material="color:#444"
                    static-body="shape: box"></a-box>
              <a-entity position="-0.305 0.605 0.219" rotation="0 90 0">
                <a-plane width="0.5" height="0.2" color="#222" opacity="0.8"></a-plane>
                <a-entity text="value: Balle impossible; align: center; color: #0f0; width: 1.4"
                          position="0 0 0.01"></a-entity>
              </a-entity>
            </a-entity>

            <!-- Disclaimer de prendre qu'une seule balle à la fois -->
            <a-entity position="-0.413 0.976 0.983" rotation="0 90 0">
              <a-plane width="1.4" height="0.2" color="#222" opacity="0.8"></a-plane>
              <a-entity text="value: Prenez une seule balle à la fois!; align: center; color: #f00; width: 2"
                        position="0 0 0.01"></a-entity>
            </a-entity>
          <!-- OBJETS SAISISSABLES (physiques) -->
          <!-- Boules de bowling -->

          <!-- facile -->
          <a-sphere id="ball-easy" class="bowling-ball grabbable" resettable position="-0.081 0.170 0.408" radius="0.15" color="#EF2D5E"
                    shadow="cast: true; receive: true" opacity="0"
                    grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                    dynamic-body="mass: 10; shape: sphere"
                    sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                    sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                    sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                    <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.19 0.19 0.19"></a-entity>
          </a-sphere>

            <!-- moyen -->
          <a-sphere id="ball-medium" class="bowling-ball grabbable" resettable position="-0.081 0.170 0.918" radius="0.1" color="#EF2D5E"
                    shadow="cast: true; receive: true" opacity="0"
                    grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                    dynamic-body="mass: 1; shape: sphere"
                    sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                    sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                    sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                    <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.126 0.126 0.126"></a-entity>
          </a-sphere>

            <!-- difficile -->
          <a-sphere id="ball-hard" class="bowling-ball grabbable" resettable position="-0.081 0.170 1.428" radius="0.05" color="#EF2D5E"
                    shadow="cast: true; receive: true" opacity="0"
                    grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
                    dynamic-body="mass: 0.1; shape: sphere"
                    sound__throw="src: #sfx-throw; volume: 0.7; poolSize: 3"
                    sound__roll="src: #sfx-roll; loop: true; volume: 0.5; poolSize: 1; refDistance: 0.8; rolloffFactor: 1.5"
                    sound__pins="src: #sfx-pin; volume: 0.7; poolSize: 3; refDistance: 1; rolloffFactor: 1.5">
                    <a-entity id="ballmodel" gltf-model="#bowlingball" position="-0.013 0.014 0.008" scale="0.063 0.063 0.063"></a-entity>
          </a-sphere>
        </a-entity>

        <!-- Quilles alignées façon bowling (1–2–3–4) -->
        <!-- Quilles bowling resserrées (écart entre lignes réduit) -->
        <a-entity id="pins" rotation="0 0 0" position="0.008 0.1 -2.5">
          <a-cylinder class="grabbable" resettable position="1.0 0.1 -1.9" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.9 0.1 -2.1" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.1 0.1 -2.1" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.8 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.0 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.2 0.1 -2.3" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>

          <a-cylinder class="grabbable" resettable position="0.7 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="0.9 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.1 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
          <a-cylinder class="grabbable" resettable position="1.3 0.1 -2.5" radius="0.05" height="0.3" color="#FFC65D"
            shadow="cast: true; receive: true" opacity="0"
            grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend"
            dynamic-body="mass: 0.75; shape: cylinder">
            <a-entity id="pinmodel" gltf-model="#bowlingpin" position="0 0.04 0" scale="0.13 0.13 0.13"></a-entity>
          </a-cylinder>
        </a-entity>

        <!-- murs invisibles -->
        <a-box position="1 1.5  2" width="4" height="3" depth="0.1"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <a-box position="1 1.5 -7" width="4" height="3" depth="0.1"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <a-box position="-1 1.5 -2" width="0.1" height="3" depth="10"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <a-box position="3 1.5 -2" width="0.1" height="3" depth="10"
              material="opacity: 0; transparent: true"
              static-body="shape: box"></a-box>

        <!-- Règle au dessus du mur du fond-->
        <a-entity id="game-rules" position="0 2 -5.6">
          <a-plane width="2.5" height="1.5" color="#222" opacity="0.8" position="1 0 0"></a-plane>
          <a-entity text="value: Regle du jeu:
                                - Prenez une seule balle a la fois.
                                - Lancez-la en la lachant ou en la projetant.
                                - Apres chaque lancer, attendez que la balle soit revenue et que les quilles soient immobiles.
                                - Appuyez sur le bouton RESET pour recommencer une partie.
                                \nCe jeu a ete realise dans le cadre du projet WebVR par Fabio MALTA, Nicolas POROT, Mateo BIAUT et Benjamin JOANNARD; align: center; color: #fff; width: 2.2"
                    position="1 0 0.01"></a-entity>
        </a-entity>


        <a-entity id="announcer"
          sound__strike="src: #sfx-strike; volume: 0.9; positional: false"
          sound__spare="src: #sfx-spare;  volume: 0.8; positional: false"
          sound__gutter="src: #sfx-gutter; volume: 0.7; positional: false">
        </a-entity>

        <a-entity id="bgm"
          bgm-controller
          sound__bgm="src: #sfx-music; loop: true; positional: false; autoplay: false; volume: 0.25">
        </a-entity>

        <a-entity id="tung" gltf-model="#tung" position="-0.3 0 -0.3" scale="0.1 0.1 0.1" rotation="0 45 0">
          <!-- text tung tung sahur-->
          <a-entity text="value: Salut l'ami !\n Fais attention a ne pas depasser la ligne blanche avec la balle sinon, cela comptera comme un lance.; align: center; color: #FFF; width: 15"
                    position="0 16 0"></a-entity>
        </a-entity>


       <!-- SOL : à y = 0 (garde shape: plane) -->
        <a-plane position="0 -0.1 -1" rotation="-90 0 0" width="100" height="100" opacity="0"
                shadow="cast: false; receive: true"
                static-body="shape: plane"
                material="shader: flat; src: #groundTexture; repeat: 100 100"></a-plane>

        <a-sky src="#skyTexture"></a-sky>
      </a-scene>
    </body>
</html>